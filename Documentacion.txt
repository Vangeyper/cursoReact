
CURSO REACT 2024 - Aprende desde cero  
Curso https://www.youtube.com/watch?v=7iobxzd_2wY   
---------------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------------

1. Importante: se usa para todas las partes : cliente y servidor. Es una biblioteca y la podemos usar desde javascript sin empaquetadores como VITE.
2. IMPORTANTE: web para consultas de todos los niveles: reactjs.wiki
3. Se crea en 2011 para solventar la problematica de interfaces graficas de formularios y con el objetivo de impedir los ataques por XSS
4. Con lo que aprendes de React Native también se pueden diseñar aplicaciones móviles.
5. También se utiliza en aplicaciones de escritorio. Microsoft ha hecho React Native for Windows + macOS
6. Soporte asegurado.
7. Tiene una API estable en el tiempo. No hay grandes modificaciones en el tiempo.
8. Comunidad inmensa.
9. Con Vanilla Javascript el código para hacer por ejemplo un boton que al pulsarlo cambie su texto es IMPERATIVO: le decimo el cómo hacerlo.
10. Si tengo varios botones en código IMPERATIVO no escala bien, estop suele ser siempre así.

11. Podemos inyectar cualquier componente react en cualquier parte de nuestra aplicación.
12. Ej.
        <div id="app"></div>

    import ReactDOM from "https://esm.sh/react-dom@18.2.0/client"
    const app = document.getElementById('app')
    const root = ReactDOM.createRoot(app)           -> react es un conjunto de componentes en forma organizativa de árbol, por eso creamos el root o raiz
    root.render('un texto')     -> funciona
    root.render('<button>Guardar</button>')         -> NO funciona como html, lo pone como texto para evitar las inyecciones XSS

13. Para poder renderizar un html requerimos crear un element y debemos importar React:
    Ej.
        import React from "https://esm.sh/react-dom@18.2.0"

        const button = React.createElement('button', { "data-id": 123 }, 'Guardar')      -> el tercer parámetro es el envoltorio, y el segundo los atributos
        root.render(button)     -> esto si renderiza un botón con el atributo data-id y el valor para el mismo de 123

14. Si ahora queremos crear 3 botones y renderizarlos:
    Ej.
        const button1 = React.createElement('button', { "data-id": 123 }, 'Guardar 1')    
        const button2 = React.createElement('button', { "data-id": 456 }, 'Guardar 2')
        const button3 = React.createElement('button', { "data-id": 789 }, 'Guardar 3')
        root.render(button1, button2, button3)     -> esto NO renderiza los botones porque solo podemos renderizar 1 elemento al mismo tiempo

15. Una forma de hacer el renderizado de los 3 botones sería envolviéndolos en un div y renderizándolo:
    Ej.
        const button1 = React.createElement('button', { "data-id": 123 }, 'Guardar 1')    
        const button2 = React.createElement('button', { "data-id": 456 }, 'Guardar 2')
        const button3 = React.createElement('button', { "data-id": 789 }, 'Guardar 3')
        const div = React.createElement('div', null, [button1, button2, button3])
        root.render(div)

16. Pero esto creará un div en nuestro html, y no queremos eso:
    En react podemos crear un envoltorio vacio con React.Fragment:
    Ej.
        const div = React.createElement(React.Fragment, null, [button1, button2, button3])
        root.render(div)

    Esto renderiza los 3 botones pero sin poner un div adicional.

17. El problema es que no hemos conseguido tener un código completamente DECLARATIVO, en la parte de createElement le estamos diciendo de forma IMPERATIVA lo que hay que hacer.
    Para tenerlo en declarativo debemos usar JSX:
    Esto es una extensión de Javascript que nos permite mediante algo similar al xml poner nuestra interfaz en formato declarativo:
    Ej.
        <React.Fragment>
            <button data-id="123">Button 1</button>
            <button data-id="456">Button 2</button>
            <button data-id="789">Button 3</button>
        </React.Fragment>
    Si ponermos root.render(
        <button data-id="123">Button 1</button>
        <button data-id="456">Button 2</button>
    )
    petará porque solo espera un parámetro, un element. Por eso usamos el React.Fragment para envolver a todos los botones y pasarlo como un único element.

    Esto equivale a lo que teníamos antes:
    Ej.
        const button1 = React.createElement('button', { "data-id": 123 }, 'Guardar 1')    
        const button2 = React.createElement('button', { "data-id": 456 }, 'Guardar 2')
        const button3 = React.createElement('button', { "data-id": 789 }, 'Guardar 3')
        const div = React.createElement(React.Fragment, null, [button1, button2, button3])
        root.render(div)

18. IMPORTANTE: la transformación de JSX a el código javascript normal la hace mediante 2 herramientas: BABEL y SWC    
    Es decir, el JSX es Javascript, pero mucho más entendible que el resultado final de teclearlo de la forma tradicional.

19. JSX:
    19.1. Expresiones (poniendo la const o variable entre llaves):
        Ej. 
            const name = 'Miguel'
            <h1>Hola, {name}>

        Se puede hacer lo mismo con funciones
        Ej.
            const element = <strong>Número aleatorio. {Math.random()}</strong>
        Entre las {} solo podemos tener expresiones, NO declaraciones, por ejemplo un if no se puede.

    19.2. Curiosidad: los atributos en JSX al ser Javascript y no html se nombran con la nomenclatura CamelCase
        Ej.
            <button tabIndex="1">     -> no se pone tab-index
    
20. Para hacer una app con react usaremos un empaquetador de aplicaciones:
    20.1. Usar: npx create-react-app.dev my-app
                cd my-app
                npm start
        Esto utiliza webpack que ahora ya está superado como empaquetador.
    20.2. Usar Vite:
        npm init -y
        mkdir projects
        cd projects
        npm create vite@latest
            Preguntará nombre del proyecto: 00-hola-mundo
            React
            TypeScript o JavaScript + SWC
        cd 00-hola-mundo
        npm install
        npm run dev

        Vite ya detecta archivos con JSX y los transpila con SWC a Javascript.
    
21. PRIMER PROYECTO:
    Importante ver que en nuestro index.html tenemos el root e incluímos el punto de entrada de nuestra app:
    Ej.
        <body>
            <div id="root"></div>
            <script type="module" src="/src/main.jsx"></script>  -> punto de entrada
        </body>

    En nuestro main.jsx tenemos:
    Ej.
        import React from 'react'
        import ReactDOM from 'react-dom/client'
        import App from './App'
        import './index.css'

        ReactDOM.createRoot(document.getElementById('root')).render(
            <React.StrictMode>
                <App />
            </React.StrictMode>
        )

22. para poner varios botones con código repetido lo que necesitamos es crear un Componente que tenga algunas cosas que cambian pero la base se
    reutilice. COMPONENTE: es una función que crea un elemento que luego podemos reutilizar.

23. Podríamos haber creado una función de creación del botón y llamarla 3 veces:
    Ej.
        const createButton = ({text}) => {
            // aquí podríamos darle estilos, añadir iconos y complicarlo todo lo que quisieramos
            <button>{text}</button>
        }
    
        root.render(
            <React.Fragment>
                {createButton({ text: 'Button 1' })}
                {createButton({ text: 'Button 2' })}
                {createButton({ text: 'Button 3' })}
            </React.Fragment>
        )

    Pero esto aunque estaría bien sigue siendo IMPERATIVO y no DECLARATIVO como hemos dicho que pretende React.

24. Para hacer el componente del button en react sería de esta forma:
    Ej.
        Le ponemos un nombre al componente, no le indicamos que lo vamos a crear:
        const Button = ({text}) => {
            // aquí podríamos darle estilos, añadir iconos y complicarlo todo lo que quisieramos
            <button>{text}</button>
        }

        Y para indicar que queremos tener 3 botones lo hacemos de forma declarativa:

        root.render(
            <React.Fragment>
                <Button text = 'Button 1'></Button>
                <Button text = 'Button 2'></Button>
                <Button text = 'Button 3'></Button>
            </React.Fragment>
        )

25. IMPORTANTE: los componentes tienes que seguir la nomenclatura Pascal Case. Esto es porque react no es capaz de diferenciar entre componentes y elementos html en caso de no cumplir con esta nomenclatura. 
    Al empezar con mayúsculas sabe que es un componente. 
    Para ver la diferencia de nomenclaturas:
        PascalCase
        camelCase    
        snake_case
        kebab-case

26. ESTILOS en react:
    Se pueden importar archivos css
    También podemos usar estilos en línea, pero en lugar de ponerlos como un string debemos hacerlo como un objeto:
    Ej.
        <article style={{ display: 'flex', alignItems: 'center'}}></article>
    Lo correcto es usar importacion de archivos css, pero a veces no se puede y hay que usar los estilos en línea. 
    También en react native habrá que usar estilos en línea.

27. IMPORTANTE: para determinar o indicar la clase en un elemento debemos utilizar className, puesto que class es una palabra reservada de Javascript.

28. Para los estilos podemos usar BEM o SUIT. Puedes aplicar CSS Modules

29. IMPORTANTE: existe una web con componentes de react ya creados y estilados: chakra-ui.com

30. IMPORTANTE: un componente será reutilizable si podemos pasarle propiedades o parámetros para poder adaptarlo a nuestra necesidad. Si no tienen parámetros no es reutilizable, siempre será único.

31. IMPORTANTE: Para devolver más de un elemento en react tenemos que utilizar el React.Fragment envolviéndolos, pero existe un atajo:
        <> ...elementos... </>   es lo mismo que poner <React.Fragment> ...elementos... </React.Fragment>

32. Cuando estilamos hay que tener presente que no pongamos estilos para arreglar un componente en el contexto actual pero que en otro contexto no quedaría bien, por ejemplo un margin-top de un elemento.
    Para eso es mejor estilar el componente padre, o hacerlo de manera que siempre se vea bien.

33. IMPORTANTE: para pasar un parámetro booleano a un componente:
    1. Si le pasamos "true" lo interpreta como un string que escribe true no como booleano.
    2. Hay que interpretarlo poniendolo entre llaves: {true}
        Ej.
            <TwitterFollowCard
                key="key"
                userName="nombre"
                initialIsFollowing={false}
                >
                "Nombre"
            </TwitterFollowCard>
    3. Podemos ahorrarnos las llaves si le pasamos directamente una variable booleana
        Ej.
            <TwitterFollowCard
                key="key"
                userName="nombre"
                initialIsFollowing
                >
                "Nombre"
            </TwitterFollowCard>
    4. No podemos pasarle un negado de una variable booleana.
        Ej.
            <TwitterFollowCard
                key="key"
                userName="nombre"
                !initialIsFollowing
                >
                "Nombre"
            </TwitterFollowCard>
        Esto da error, hay que pasarle el {false}

34. IMPORTANTE: también podemos pasarle funciones como props o parámetros al componente. Las funciones en javascript son de primera clase, con lo que podemos pasarlas como parámetros.
    OJO: no es lo mismo pasar la función que pasar la ejecución de la función. Para pasar la ejecución es miFuncion = {funcionName()} mientras que para pasar la función es miFuncion = {funcionName}
    donde funcionName es el nombre de la función.

35. CLAVE ==>>  ¿ cuál es la diferencia entre un ELEMENTO y un COMPONENTE ?: un componente es como una factoría de elementos, es una función que al ejecutarla te devuelve un elemento.

36. IMPORTANTE: las props deberían ser inmutables => no debemos modificar el valor de las props dentro del componente. Lo correcto es hacer una copia en una constante o variable y luego modificarla.

37. CLAVE ==>> CHILDREN: es una prop especial que hace referencia a todos los hijos de un elemento, pueden ser uno o varios.
    Ej.
        <TwitterFollowCard
            key={userName}
            userName={userName}
            initialIsFollowing={isFollowing}
            >
            {name}                  -> esto sería el children
        </TwitterFollowCard>

    En el componente podemos acceder a la prop como children:
    Ej.
        export function TwitterFollowCard ({ children, userName, initialIsFollowing }) {
        const [isFollowing, setIsFollowing] = useState(initialIsFollowing)

        console.log('[TwitterFollowCard] render with userName: ', userName)

        const text = isFollowing ? 'Siguiendo' : 'Seguir'
        const buttonClassName = isFollowing
            ? 'tw-followCard-button is-following'
            : 'tw-followCard-button'

        const handleClick = () => {
            setIsFollowing(!isFollowing)
        }

        return (
            <article className='tw-followCard'>
            <header className='tw-followCard-header'>
                <img
                className='tw-followCard-avatar'
                alt='El avatar de midudev'
                src={`https://unavatar.io/${userName}`}
                />
                <div className='tw-followCard-info'>
                <strong>{children}</strong>
                <span className='tw-followCard-infoUserName'>@{userName}</span>
                </div>
            </header>

            <aside>
                <button className={buttonClassName} onClick={handleClick}>
                <span className='tw-followCard-text'>{text}</span>
                <span className='tw-followCard-stopFollow'>Dejar de seguir</span>
                </button>
            </aside>
            </article>
            )
        }
        
    En ese caso es un texto el contenido de children con el nombre.

38. IMPORTANTE: normalmente lo más importante de un componente que además quieres que sea extensible y modificable al máximo debería ser un children.
    No indicar children como un paso de prop normal, solo hace falta ponerlo en el componente no en el paso de parámetros, puesto que ya tienen entidad por sí sola.

39. Se pueden pasar todas las props en un objeto mediante Rest Operator:
    Ej.
        const midu = {isFollowing: false, userName: 'midudev'}
        const ferap = {isFollowing: true, userName: 'ferap'}

        return (
            <section className="App"
                <TwitterFollowCard
                        {...midu}
                    >
                    Miguel Angel
                </TwitterFollowCard>
                <TwitterFollowCard
                        {...ferap}
                    >
                    Pedro Santos
                </TwitterFollowCard>
            </section>
        )

    IMPORTANTE: no es una buena práctica porque puedes enviar información innecesaria y porque puedes provocar que el componente se renderice sin necesidad. Además suele ser menos claro. Solo en determinados casos puede darse por bueno.

40. ESTADO: foto del entorno y sus valores en un momento dado. 

41. HOOK: te permiten añadir cierta funcionalidad a tus componentes. Utilidades de React para dotar de funcionalidad en el renderizado a tus componentes.

42. Añadir un estado a un componente:
    Ej.
        const [isFollowing, setIsFollowing] = useState(initialIsFollowing)    -> donde lo inicializamos con initialIsFollowing
            isFollowing    -> es el estado o nombre de la variable que lo contiene
            setIsFollowing -> es la función que permite modificar ese estado 

    IMPORTANTE: este estado es INTERNO, está a nivel del componente.

43. IMPORTANTE: se llama React por su capacidad de reacción cuando hay un cambio de estado lo refleja en la UI renderizando las partes que hagan falta.

44. DOM Virtual: React solo cambia la parte necesaria para que el renderizado muestre los cambios de estado, lo hace de manera quirúrjica. Para ello React hace una foto de lo que hay renderizado en pantalla (DOM) y cuando se produce
    un cambio de estado busca las diferencias con el nuevo renderizado, este nuevo renderizado se genera en memória en forma de arbol antes de pintarlo (Virtual DOM) y entonces actualiza solo las partes que han cambiado comparando el DOM y el Virtual DOM. 
    REACT renderiza el contenido de forma automática en 2 casos:
        1. Cuando ha cambiado el estado interno de algún componente. 
        2. Cuando un componente padre se vuelve a renderizar y propaga los cambios hacia abajo. Cuando se renderiza un componente se renderizan todos los componentes que hay debajo o implicados en su renderizado.
            Esto pasa por tener estructura de árbol, solo se renderizan los hijos del componente que ha modificado su estado y él mismo, no los padres.        
    CLAVE ==>>  se renderizan de nuevo TODOS los componentes hijo del padre que ha cambiado el estado, aunque no sufran cambios concretos dichos componentes hijo. PERO, cuando React va a renderizar el componente, padre con sus hijos solo
    renderiza o pinta los cambios, por lo que los componentes hijos que no han modificado su html no se pintan de nuevo, aunque se han ejecutado dichos componentes para generar el html de renderizado de nuevo.
    No sobreescribe el DOM, lo deja intacto. Este proceso se hace comparando el DOM con el Virtual DOM y se llama RECONCILIATION.

45. CLAVE ==>> OPTIMIZACIONES: una optimización consiste en evitar que si ciertos componentes hijos no han cambiado nada no se rendericen ni ejecuten sus códigos aunque se modifique el componente padre.

46. De hijos a padres no podemos pasar props, pero podemos pasar callbacks.

47. No hay un hook para manejar el localStorage, pero como es javascript podremos crear nuestros propios hooks para eso y otras cosas.

48. Los comentarios de toda la vida de javascript se pueden incorporar en un componente react:  // comentario,  /* comentarios */
    Pero dentro de la parte de render (return()) del componente tendremos que utilizar { /* comentarios */ }  para que lo interprete, sino lo pondría como renderizado en pantalla.
    No suele ser buena práctica poner comentarios dentro del render.

49. Inicializamos los valores del estado en ocasiones si ya tienen valor previo a la entrada al componente con props, que se llamarán:  initialIsFollowing. 
    Ej.
        export function TwitterFollowCard ({ children, userName, initialIsFollowing }) {
            const [isFollowing, setIsFollowing] = useState(initialIsFollowing)

50. CLAVE ==>> Las props que se usan para inicializar un estado en un componente solo se aplican una vez, luego ya no se vuelven a usar aunque cambiemos su valor. Solo sirven para inicializar el estado la primera vez que renderizamos el componente.
    Por lo que no sirve tener un estado en el componente padre y pasárselo a los hijos como prop de initialIsFollowing pretendiendo que se actualicen los estados de los hijos. 

51. Utilizamos el componente para renderizar una lista de usuarios: como es javascript podemos usar un map de los usuarios y con eso ya lo tendríamos. Envolvemos entre llaves lo que queremos renderizar del componente padre:
    Ej.
        import { TwitterFollowCard } from './TwitterFollowCard.jsx'

        const users = [
        {
            userName: 'midudev',
            name: 'Miguel Ángel Durán',
            isFollowing: true
        },
        {
            userName: 'pheralb',
            name: 'Pablo H.',
            isFollowing: false
        },
        {
            userName: 'PacoHdezs',
            name: 'Paco Hdez',
            isFollowing: true
        },
        {
            userName: 'TMChein',
            name: 'Tomas',
            isFollowing: false
        }
        ]

        export function App () {
        return (
            <section className='App'>
            {
                users.map(({ userName, name, isFollowing }) => (
                <TwitterFollowCard
                    key={userName}
                    userName={userName}
                    initialIsFollowing={isFollowing}
                >
                    {name}
                </TwitterFollowCard>
                ))
            }
            </section>
        )
        }

52. IMPORTANTE: cuando renderizamos una lista o mapeo de elementos debemos indicar la KEY de cada uno de ellos o nos saldrá un warning en el explorador. Esto es porque así react puede identificar 
    cada elemento del array cuando hace sus comparaciones con el DOM Virtual y el DOM. Este valor de la Key es y debe ser único. El index puede usarse como Key si sabemos que cada elemento tiene siempre 
    el mismo índice, si van cambiando pueden darse problemas de rendering. El valor de la Key debe ser algo único de ese elemento.
    OJO: usar key = {Math.random()} no tiene sentido, porque cada vez que se renderice tendremos un valor diferente para el mismo elemento.
    Un Date.now tampoco sirve, ni en general nada aleatorio. Debe ser único para cada elemento. Con el Date.now() podemos tener duplicados y producirse duplicación de elementos renderizados.
    Con el Math.random() puede ser que funcione el render, pero tendremos un problema de rendimiento ya que renderizará todos los elementos.

---------------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------------



Curso de React desde cero: Crea un videojuego y una aplicación para aprender useState y useEffect
https://www.youtube.com/watch?v=qkzcjwnueLA
---------------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------------

53. Si modificas cualquier variable de estado debes hacerlo con su correspondiente función, sino react no sabrá que tiene que renderizar el componente afectado y sus hijos.
    Ej.
        // actualizar el tablero
        const newBoard = [...board]  => hacemos una copia para poder modificar el tablero sin tocar el original
        newBoard[index] = turn       => lo modificamos en la copia
        setBoard(newBoard)           => cambiamos el estado con las modificaciones en el original

54. Para evitar que nos deje modificar un valor ya existente en el tablero:
    Ej.
        // no actualizamos esta posición
        // si ya tiene algo
        if (board[index]) return

55. CAMBIO de ESTADO: el cambio de estado en react es asíncrono, y puede por lo tanto tardar más que el alert.
    Ej.
        // revisar si hay ganador
        const newWinner = checkWinnerFrom(newBoard)
        if (newWinner) {
            setWinner(newWinner)
            alert(`el ganador es ${newWinner}`)  =>  OJO se pintará el alert en pantalla conforme has ganado pero no verás el último movimiento del usuario en pantalla, porque la actualización de los estados es asíncrona
        }

    Por eso usamos los valores a futuro para validaciones de cosas que ya ha hecho el usuario, pero que el estado todavía no regleja.

56. Para poder resetear y volver a empezar de nuevo el juego basta con asegurar de volver a tener los estados como al principio del juego.
    Ej.
        const resetGame = () => {
            setBoard(Array(9).fill(null))
            setTurn(TURNS.X)
            setWinner(null)
        }

57. Para chequear si hemos terminado el juego sin ganador:
    Ej.
        export const checkEndGame = (newBoard) => {
            // revisamos si hay un empate
            // si no hay más espacios vacíos
            // en el tablero
            return newBoard.every((square) => square !== null)    => si no existe ningun null es que hemos completado el tablero
        }

58. Los hooks de useState no deben meterse dentro de un if porque react pierde las posiciones de los mismos y necesita tenerlas. No pueden estar dentro de lógica que cambie su
    posición en el componente, esta debe ser unívoca y clara para react.

59. Guardar el estado de la partida en localStorage:
    Ej.
        export const saveGameToStorage = ({ board, turn }) => {
            // guardar aqui partida
            window.localStorage.setItem('board', JSON.stringify(board))
            window.localStorage.setItem('turn', turn)
        }

60. Recuperar el estado de la partida guardado y si existe inicializar el estado de la misma:
    Ej.
        const [board, setBoard] = useState(() => {
            const boardFromStorage = window.localStorage.getItem('board')
            if (boardFromStorage) return JSON.parse(boardFromStorage)
            return Array(9).fill(null)
        })
    No podemos condicionar como hemos dicho en el punto 58 el hook, pero podemos condicionar el valor que inicializamos.

    CLAVE ==>> la lectura del localStorage es lenta y debemos evitar hacerla si no es necesario. Si la ponemos dentro del useState del board solo se hará en los casos en que se 
    inicialice el tablero, pero si la ponemos justo antes lo hará cada vez que se renderice el componente.

    Lo mismo hacemos con los turnos:
    Ej.
        const [turn, setTurn] = useState(() => {
            const turnFromStorage = window.localStorage.getItem('turn')
            return turnFromStorage ?? TURNS.X
        })

61. Hay que acordarse de resetear los valores del localStorage cuando reseteamos el juego:
    Ej.
        const resetGame = () => {
            setBoard(Array(9).fill(null))
            setTurn(TURNS.X)
            setWinner(null)

            resetGameStorage()
        }

62. useEffect: es un hook que nos permite ejecutar código arbitrario cuando el componente se monta en el DOM y cada vez que cambian las dependencias que nosotros le indicamos
    Ej.
        useEffect(() => {
            document.body.classList.toggle('no-cursor', enabled)

            return () => {
            document.body.classList.remove('no-cursor')
            }
        }, [enabled])

    Tiene como parámetros una función y luego una lista opcional de valores sobre los que ejercerá el control y en caso de cambiar ejecutará la función. También ejecutará la función al 
    montar el componente donde esté.

    Si la lista de valores no está informada la función se ejecutará cada vez que se renderice el componente.

    Si la lista de valores está vacía [] se ejecutará solo la primera vez que se renderice el componente.

    Cuando informamos valores en la lista es como suscribirse a un evento. Se ejecutará siempre que pase.

    CLAVE ==>> usamos el useEffect para cargar listeners o apis de terceros que no tiene sentido que se ejecuten cada vez que se renderice el componente, así lo ejecutaremos cuando queramos.

    No permiten parámetros las funciones useEffect.

63. CLAVE ==>> Requisitos para instalar en los proyectos:
    1. npm install standard -D      => son reglas de linter 
    2. En el package.json aparcerá el standard recien instalado, y añadiremos lo siguiente:
        Ej. 
            "devDependencies": {
                "standard": "17.0.0"
            },
            "eslintConfig": {
                "extends": "./node_modules/standard/eslintrc.json"
            }
    3. Instalamos la extensión de eslint en el visual studio code
    Ahora cuando abrimos una página nos salen advertencias de posibles errores de sintaxis, espacios, comillas, lineas, ... Al guardar si tenemos activado el corrector automático o editor automático nos lo 
    corregirá automáticamente.

64. Proyecto para que una animación siga al puntero por la pantalla:
    Ej. 
        // pointer move
        useEffect(() => {
            console.log('effect ', { enabled })

            const handleMove = (event) => {
            const { clientX, clientY } = event
            setPosition({ x: clientX, y: clientY })
            }

            if (enabled) {                                          => importante, solo añadimos el listener si esta activo el enabled
                window.addEventListener('pointermove', handleMove)
            }

            // cleanup:
            // -> cuando el componente se desmonta
            // -> cuando cambian las dependencias, antes de ejecutar
            //    el efecto de nuevo
            return () => { // cleanup method
                console.log('cleanup')
                window.removeEventListener('pointermove', handleMove)           => CLAVE ==>> CLEAN useEffect: las suscripciones las tenemos que limpiar, 
            }                                                                                 porque persisten en el tiempo, react no las cancela
        }, [enabled])

    CLAVE ==>> no podemos meter el useEffect en el condicional  if(enabled)   ni en ningún otro por lo que habíamos dicho de la posición de los hook en react.

    Es buena práctica inicializar con valores siempre que podamos, sino con null.
    Ej.
        const [position, setPosition] = useState({ x: 0, y: 0 })

    
65. CLAVE ==>> CLEAN useEffect: las suscripciones las tenemos que limpiar, porque persisten en el tiempo, react no las cancela. ¿Cuando hacer esas limpiezas? pues en el return() 
    que podemos indicar para las funciones useEffect. Podemos declarar una función que haga estas limpiezas.
    Ej.
        return () => { // cleanup method
            console.log('cleanup')
            window.removeEventListener('pointermove', handleMove)           
        }        

    ¿Cuando se ejecuta este return? 
        1. Siempre que se desmonte el componente
        2. Cada vez que cambien las dependencias de la función useEffect -> se ejecuta antes del propio useEffect, realiza una limpieza previa antes del nuevo efecto.

66. CLAVE ==>> Si no limpiamos las suscripciones en las funciones useEffect no solo tendremos un problema de funcionamiento, sino que se irán creando nuevas suscripciones ocupando 
    recursos y penalizando el rendimiento del app.

67. CLAVE ==>> Si queremos saber cuantas suscripciones se han realizado a un determinado evento en el chrome podemos ir a Consola y poner: getEventListeners(window)
    Nos indicará un array con las suscripciones a cada evento en caso de existir más de una. Con esto podremos ver si estamos limpiando bien los eventos. También sirve para
    determinar problemas de rendimiento en páginas web.

68. React.StrictMode: se utiliza para que te de avisos si estás haciendo algo incorrecto, si estás utilizando react antiguo, y tiene una particularidad al montar los componentes: 
    ejecuta el efecto del componente, ejecuta el cleanup del mismo componente y luego vuelve a ejecutar el efecto del componente. Esto solo pasa en desarrollo, y ejecuta entonces
    2 veces los componentes. Es una ayuda para detectar malos funcionamientos en desarrollo. El React.StrictMode en producción lo ignora y es como si no existiera. En desarrollo 
    si quisieramos podemos quitarlo y dejará de hacer el doble ejecutor.

69. CLAVE ==>> React Developer Tools: son unas herramientas de desarrollo para cualquier explorador de windows de los más conocidos.
    Una vez instalada nos indicará en un inconito superior derecho si estamos en desarrollo o producción, el primer caso aparece en rojo con un escarabajo de debug.
    Si miramos al final hay 2 nuevas opciones: 
        1. Profiler:
            Ejecutamos nuestra aplicación después de darle a grabar en Profiler y luego miramos en profiler, podremos ver temas de rendimiento. Le tenemos que dar a grabar y despues de parar 
            la grabación podremos estudiar el comportamiento de nuestra app web. Indicando las renderizaciones y qué las ha causado. 
        2. Components:
            Los nombres de los componentes en producción normalmente están minificados, salvo que hubieran puesto el DisplayName.
            Pero en desarrollo lo veremos todo, y no solo los componentes, podremos ver sus props y estados y podremos cambiar sus valores. Veremos los hooks. Y como en html al hacer click sobre un
            componente lo seleccionarán en la pantalla del la web. Esto nos permite ver si modificamos el estado como responde nuestra UI.
            Es super potente porque te permite replicar situaciones en los cambios de estado por ejemplo que nos permetirá reproducir errores o momentos del web.
            Otra cosa interesante es que muestra el arbol de componentes completo del web. Los valores solo los permite cambiar en desarrollo.

70. Montar un useEffect para quitar / ocultar el mouse en pantalla:
    Ej.
        // change body className
        useEffect(() => {
            document.body.classList.toggle('no-cursor', enabled)

            return () => {
            document.body.classList.remove('no-cursor')
            }
        }, [enabled])

71. No es una buena práctica usar un solo useEffect para hacerlo todo, es mejor tener varios cada uno con su objetivo.

72. Dentro de Netlify tenemos app.netlify.com/drop que nos permite mediante arrastre de la carpeta dist creada por el npm run build. Si no nos registramos lo mantiene por 1 hora.


---------------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------------


Prueba Técnica de React para Juniors y Trainee
https://www.youtube.com/watch?v=XYpadB4VadY
---------------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------------

Vamos a hacer la prueba sin tener plantilla inicial de React, es decir creando un proyecto con Vite pero con Vanilla y luego lo transformamos a React.

73. creamos el proyecto Vanilla:
    Ej.
        npm create vite@latest
            react-prueba-tecnica
            Vanilla
            JavaScript

        cd react-prueba-tecnica

74. Instalamos un plugin de react
    Ej.
        npm install @vitejs/plugin-react -E
        code .

75. Tenemos la plantilla pero si abrimos el package.json vemos que no tenemos react ni sus dependencias. Las instalamos:
    Ej.
        npm install react react-dom -E
            donde react es la biblioteca de react que tiene los hooks y demás
            y react-dom es la que tiene los bindings con el navegador

76. Creamos el fichero vite.config.js o lo rellenamos con:
    Ej.
        import { defineConfig } from 'vite'
        import react from '@vitejs/plugin-react'

        export default defineConfig({
            plugins: [react()]
        })

77. CLAVE ==>> Creamos el punto de entrada de la aplicación de react (es crear el elemento raiz de la misma y poner el primer componente):
    Esto lo hacemos en nuestro main.js puesto que es el primer archivo que se carga a través de nuestro index.html
    Ej.
        import { createRoot } from 'react-dom/client'

        const root = createRoot(document.getElementById('app'))
        root.render(<h1>Hello, world!</h1>)    

    CLAVE ==>> Problema: este código no se ejecuta porque requiere la extensión .jsx para hacerlo transpilando el código con SWC o similar. Renombramos a main.jsx.
    También modificamos la referencia en index.html al nuevo archivo main.jsx

78. Instalamos el eslint:
    Ej.
        npm install standard -D

    Lo configuramos en el package.json añadiendo:
    Ej.
        ,
        "eslintConfig": {
            "extends": "./node_modules/standard/eslintrc.json"
        }

79. Creamos el Readme.md y añadimos la descripción de la prueba técnica:
    Ej.
        # Prueba técnica para Juniors y Trainees de React en Live Coding.

        APIs:

        - Facts Random: https://catfact.ninja/fact
        - Imagen random: https://cataas.com/cat/says/hello

        - Recupera un hecho aleatorio de gatos de la primera API y muestra una imagen de un gato con la primera palabra del hecho recuperado usando la segunda API.

80. Creamos el App.jsx dentro de mi src/Components
    Ej.
        export function App () {
            return (
                <h1>App de gatitos</h1>   
        )}

    Importamos el componente en nuestro main.jsx y lo llamamos en el cuerpo:
    Ej.
        import { createRoot } from 'react-dom/client'
        import { App } from './src/App.jsx'

        const root = createRoot(document.getElementById('app'))
        root.render(<App />)

81. CLAVE ==>> conforme vamos programando debemos ir mostrando cosas en la pantalla que demuestren nuestro progreso.

82. Definir la prueba en subtareas a realizar:
    - Recupera un hecho aleatorio de gatos de la primera API
    - Recuperar la primera palabra del hecho
    - Muestra una imagen de un gato con la primera palabra del hecho recuperado usando la segunda API.

    CLAVE ==>> concretar lo que devuelve la API y asegurar el endpoint que vamos a utilizar. Incluso lo pondríamos en una constante dentro de un template ya con las partes a cambiar:
        Ej.
            const CAT_ENDPOINT_RANDOM_FACT = 'https://catfact.ninja/fact'

83. Recuperamos el useState y creamos un estado fact:
    Ej.
        import {useState} from "react"

        export function App () {
            const {fact, setFact} = useState('lorem ipsum what the fact')

            CLAVE ==>> no podemos poner aquí un fetch de datos porque esto se ejecuta cada vez que renderizamos nuestro componente

            CLAVE ==>> Usamos un useEffect para que la primera vez que se va a montar nuestro componente haga el fecth

            CLAVE ==>> No olvidarse de poner la dependencia: []  o entraremos en bucle infinito y tendremos problemas 

            useEffect (() => {
                fetch('https://catfact.ninja/fact')
                    .then(res => res.json())
                    .then(data => setFact(data.fact))
            }, [])

            return (
                <main>
                    <h1>App de gatitos</h1>
                    {fact && <p>{fact}</p>}         // Usamos el renderizado condicional como algo que ya sabemos hacer
                </main>
        )}

    Un fetch devuelve una promesa que todavía no la tenemos en json, por lo que lo hacemos y después cambiamos el estado con los datos 
    
84. En useEffect si queremos poner async await debemos envolverlo:
    Ej.
        useEffect (() => {
            async function getRandomFact () {                
                const res = await fetch('https://catfact.ninja/fact')
                const json = await res.json()
                setFact(json.fact)                
            }

            getRandomFact()            
        }, [])

    CLAVE ==>> No podemos poner el async await directamente en el useEffect.

85. Justo despues de obtener el fact buscamos la primera palabra del mismo:
    Ej.
        const firstWord = fact.split(' ')[0]

    IMPORTANTE: si quieren que nos quedemos con las 3 primeras palabras:
        Ej.
            const firstWord = fact.split(' ').slice(0, 3).join(' ')
            el split obtiene un array con tantas palabras como tengamos.
            el slice obtiene las 3 primeras
            el join las une con espacios en una cadena de texto

    Una opción más óptima de este último caso es:
        Ej.
            const firstWord = fact.split(' ', 3).join(' ')

86. CLAVE ==>> para buscar cosas del lenguaje como la función para separar string por un token: 
    Ej. 
        en el buscador de google ponemos: mdn separar string por separador

87. CLAVE ==>> NO busquéis la solución a lo que os piden en google, buscar documentación de lo que necesitáis para resolverlo, pero no de ejemplos ya hechos.    

88. usamos la segunda API con nuestra primera palabra. Para guardarla necesitamos otro estado:
    Ej.
        onst [imageUrl, setImageUrl] = useState()

        useEffect (() => {
            fetch(`https://cataas.com/cat/says/${threeFirstWords}?size=50&color=red&json=true`)
                .then(res => res.json())
                .then(data => {
                    const {url} = data
                    setImageUrl(`https://cataas.com${url}`)       // esto funcionaría pero se puede hacer mejor -> punto 18
            })
        }, [])

89. Presentamos los datos obtenidos:
    Ej.
         return (
                <main>
                    <h1>App de gatitos</h1>
                    {fact && <p>{fact}</p>}         // Usamos el renderizado condicional como algo que ya sabemos hacer
                    {imageUrl && <img src={imageUrl} alt='Imágen extraida de la segunda API con 3 palabras de la primera API.' />}
                </main>
         )

    Poner el contenido del alt con un texto coherente que explique lo que hace la imagen

90. Razones por las que no poner en el estado la parte raiz de la url:
    Porque en el estado tenemos que tener lo mínimo posible, y esto lo podemos tener fuera.

91. Si os piden alinear al centro los componentes en pantalla:
    Dais estilos:
        En columna:  
        Ej.
            main {
                display: flex;
                flex-direction: column;
                place-items: center;           es lo mismo que poner justify-content: center; y align-items: center; juntos
                max-width: 800px;
                margin: 0 auto;
                font-family: system-ui;
            }
    
        Si lo queremos en fila: 

        Añadimos un section:
        Ej.
            return (
                <main>
                    <h1>App de gatitos</h1>
                    <section>
                        {fact && <p>{fact}</p>}         // Usamos el renderizado condicional como algo que ya sabemos hacer
                        {imageUrl && <img src={imageUrl} alt='Imágen extraida de la segunda API con 3 palabras de la primera API.' />}
                    </section>                    
                </main>
            )

        cambiamos los estilos:
        Ej.
            section {
                display: flex;
                justify-content: space-between;
                align-items: center;
                gap: 2rem;   
            }

            section img {
                max-width: 320px;
                height: auto;
            }

92. CLAVE ==>> los efectos en react debería tener una sola responsabilidad, si les damos varias no es una buena práctica.
    Esto distribuye las responsabilidades y evita la anidación.
    Ej.
        useEffect (() => {
            async function getRandomFact () {                
                const res = await fetch('https://catfact.ninja/fact')
                const json = await res.json()
                setFact(json.fact)                
            }

            getRandomFact()            
        }, [])

        useEffect (() => {
            if (!fact) return
            fetch(`https://cataas.com/cat/says/${threeFirstWords}?size=50&color=red&json=true`)
                .then(res => res.json())
                .then(data => {
                    const {url} = data
                    setImageUrl(`https://cataas.com${url}`)       // esto funcionaría pero se puede hacer mejor -> punto 18
            })
        }, [fact])

93. CLAVE ==>> los errores se pueden gestionar en el useEffect, pero hay que tener en cuenta que entraremos en el catch si hay errores con la petición, no con la
    respuesta. Esta la tenemos que controlar nosotros.
    Ej.
            useEffect (() => {
                fetch('https://catfact.ninja/fact')
                    .then(res => {
                        if (!res.ok) throw new Error('Error fetching fact')    // asi llegaremos al catch también si hay un error con la petición
                        return res.json()                        
                    )
                    .then(data => setFact(data.fact))
                    .catch((err) => {
                        // solo errores en la petición
                    })
            }, [])

94. Normalmente nos pedirán añadir un botón que al darle refresquemos la imagen o hagamos alguna acción sobre el componente:
    Ej.
        async function getRandomFact () {                
            const res = await fetch('https://catfact.ninja/fact')
            const data = await res.json()
            const { fact } = data
            return fact
        }

        CLAVE ==>> si separamos la lógica en funciones para poder reutilizarlas no es buena práctica pasar estados o funciones de modificación de estados de nuestro 
        componente a la función. Tiene que ser completamente reutilizable, lo que es react que se quede en el componente. Así si que podemos crearla en un archivo .js
        y luego importarla.

        useEffect (() => {
            getRandomFact().then(setFact)               CLAVE ==>> sería lo mismo que escribir: getRandomFact().then(newfact => setFact(newfact))     
        }, [])

        const handleClick = async () => {
            const newfact = await getRandomFact()
            setFact(newfact)            
        }

        <button onclick={handleClick}>Get new fact</button>

---------------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------------




Custom Hooks + Testing con Playwright: Curso de React desde cero - Parte 4
https://www.youtube.com/watch?v=x-LcbVw99o8
---------------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------------

95. CLAVE ==>> Un Custom Hook es simplemente extraer lógica de nuestros componentes para poder reutilizarla en otros componentes





---------------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------------