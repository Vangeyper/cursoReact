
CURSO REACT 2024 - Aprende desde cero  
Curso https://www.youtube.com/watch?v=7iobxzd_2wY   
---------------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------------

1. Importante: se usa para todas las partes : cliente y servidor. Es una biblioteca y la podemos usar desde javascript sin empaquetadores como VITE.
2. IMPORTANTE: web para consultas de todos los niveles: reactjs.wiki
3. Se crea en 2011 para solventar la problematica de interfaces graficas de formularios y con el objetivo de impedir los ataques por XSS
4. Con lo que aprendes de React Native también se pueden diseñar aplicaciones móviles.
5. También se utiliza en aplicaciones de escritorio. Microsoft ha hecho React Native for Windows + macOS
6. Soporte asegurado.
7. Tiene una API estable en el tiempo. No hay grandes modificaciones en el tiempo.
8. Comunidad inmensa.
9. Con Vanilla Javascript el código para hacer por ejemplo un boton que al pulsarlo cambie su texto es IMPERATIVO: le decimo el cómo hacerlo.
10. Si tengo varios botones en código IMPERATIVO no escala bien, estop suele ser siempre así.

11. Podemos inyectar cualquier componente react en cualquier parte de nuestra aplicación.
12. Ej.
        <div id="app"></div>

    import ReactDOM from "https://esm.sh/react-dom@18.2.0/client"
    const app = document.getElementById('app')
    const root = ReactDOM.createRoot(app)           -> react es un conjunto de componentes en forma organizativa de árbol, por eso creamos el root o raiz
    root.render('un texto')     -> funciona
    root.render('<button>Guardar</button>')         -> NO funciona como html, lo pone como texto para evitar las inyecciones XSS

13. Para poder renderizar un html requerimos crear un element y debemos importar React:
    Ej.
        import React from "https://esm.sh/react-dom@18.2.0"

        const button = React.createElement('button', { "data-id": 123 }, 'Guardar')      -> el tercer parámetro es el envoltorio, y el segundo los atributos
        root.render(button)     -> esto si renderiza un botón con el atributo data-id y el valor para el mismo de 123

14. Si ahora queremos crear 3 botones y renderizarlos:
    Ej.
        const button1 = React.createElement('button', { "data-id": 123 }, 'Guardar 1')    
        const button2 = React.createElement('button', { "data-id": 456 }, 'Guardar 2')
        const button3 = React.createElement('button', { "data-id": 789 }, 'Guardar 3')
        root.render(button1, button2, button3)     -> esto NO renderiza los botones porque solo podemos renderizar 1 elemento al mismo tiempo

15. Una forma de hacer el renderizado de los 3 botones sería envolviéndolos en un div y renderizándolo:
    Ej.
        const button1 = React.createElement('button', { "data-id": 123 }, 'Guardar 1')    
        const button2 = React.createElement('button', { "data-id": 456 }, 'Guardar 2')
        const button3 = React.createElement('button', { "data-id": 789 }, 'Guardar 3')
        const div = React.createElement('div', null, [button1, button2, button3])
        root.render(div)

16. Pero esto creará un div en nuestro html, y no queremos eso:
    En react podemos crear un envoltorio vacio con React.Fragment:
    Ej.
        const div = React.createElement(React.Fragment, null, [button1, button2, button3])
        root.render(div)

    Esto renderiza los 3 botones pero sin poner un div adicional.

17. El problema es que no hemos conseguido tener un código completamente DECLARATIVO, en la parte de createElement le estamos diciendo de forma IMPERATIVA lo que hay que hacer.
    Para tenerlo en declarativo debemos usar JSX:
    Esto es una extensión de Javascript que nos permite mediante algo similar al xml poner nuestra interfaz en formato declarativo:
    Ej.
        <React.Fragment>
            <button data-id="123">Button 1</button>
            <button data-id="456">Button 2</button>
            <button data-id="789">Button 3</button>
        </React.Fragment>
    Si ponermos root.render(
        <button data-id="123">Button 1</button>
        <button data-id="456">Button 2</button>
    )
    petará porque solo espera un parámetro, un element. Por eso usamos el React.Fragment para envolver a todos los botones y pasarlo como un único element.

    Esto equivale a lo que teníamos antes:
    Ej.
        const button1 = React.createElement('button', { "data-id": 123 }, 'Guardar 1')    
        const button2 = React.createElement('button', { "data-id": 456 }, 'Guardar 2')
        const button3 = React.createElement('button', { "data-id": 789 }, 'Guardar 3')
        const div = React.createElement(React.Fragment, null, [button1, button2, button3])
        root.render(div)

18. IMPORTANTE: la transformación de JSX a el código javascript normal la hace mediante 2 herramientas: BABEL y SWC    
    Es decir, el JSX es Javascript, pero mucho más entendible que el resultado final de teclearlo de la forma tradicional.

19. JSX:
    19.1. Expresiones (poniendo la const o variable entre llaves):
        Ej. 
            const name = 'Miguel'
            <h1>Hola, {name}>

        Se puede hacer lo mismo con funciones
        Ej.
            const element = <strong>Número aleatorio. {Math.random()}</strong>
        Entre las {} solo podemos tener expresiones, NO declaraciones, por ejemplo un if no se puede.

    19.2. Curiosidad: los atributos en JSX al ser Javascript y no html se nombran con la nomenclatura CamelCase
        Ej.
            <button tabIndex="1">     -> no se pone tab-index
    
20. Para hacer una app con react usaremos un empaquetador de aplicaciones:
    20.1. Usar: npx create-react-app.dev my-app
                cd my-app
                npm start
        Esto utiliza webpack que ahora ya está superado como empaquetador.
    20.2. Usar Vite:
        npm init -y
        mkdir projects
        cd projects
        npm create vite@latest
            Preguntará nombre del proyecto: 00-hola-mundo
            React
            TypeScript o JavaScript + SWC
        cd 00-hola-mundo
        npm install
        npm run dev

        Vite ya detecta archivos con JSX y los transpila con SWC a Javascript.
    
21. PRIMER PROYECTO:
    Importante ver que en nuestro index.html tenemos el root e incluímos el punto de entrada de nuestra app:
    Ej.
        <body>
            <div id="root"></div>
            <script type="module" src="/src/main.jsx"></script>  -> punto de entrada
        </body>

    En nuestro main.jsx tenemos:
    Ej.
        import React from 'react'
        import ReactDOM from 'react-dom/client'
        import App from './App'
        import './index.css'

        ReactDOM.createRoot(document.getElementById('root')).render(
            <React.StrictMode>
                <App />
            </React.StrictMode>
        )

22. para poner varios botones con código repetido lo que necesitamos es crear un Componente que tenga algunas cosas que cambian pero la base se
    reutilice. COMPONENTE: es una función que crea un elemento que luego podemos reutilizar.

23. Podríamos haber creado una función de creación del botón y llamarla 3 veces:
    Ej.
        const createButton = ({text}) => {
            // aquí podríamos darle estilos, añadir iconos y complicarlo todo lo que quisieramos
            <button>{text}</button>
        }
    
        root.render(
            <React.Fragment>
                {createButton({ text: 'Button 1' })}
                {createButton({ text: 'Button 2' })}
                {createButton({ text: 'Button 3' })}
            </React.Fragment>
        )

    Pero esto aunque estaría bien sigue siendo IMPERATIVO y no DECLARATIVO como hemos dicho que pretende React.

24. Para hacer el componente del button en react sería de esta forma:
    Ej.
        Le ponemos un nombre al componente, no le indicamos que lo vamos a crear:
        const Button = ({text}) => {
            // aquí podríamos darle estilos, añadir iconos y complicarlo todo lo que quisieramos
            <button>{text}</button>
        }

        Y para indicar que queremos tener 3 botones lo hacemos de forma declarativa:

        root.render(
            <React.Fragment>
                <Button text = 'Button 1'></Button>
                <Button text = 'Button 2'></Button>
                <Button text = 'Button 3'></Button>
            </React.Fragment>
        )

25. IMPORTANTE: los componentes tienes que seguir la nomenclatura Pascal Case. Esto es porque react no es capaz de diferenciar entre componentes y elementos html en caso de no cumplir con esta nomenclatura. 
    Al empezar con mayúsculas sabe que es un componente. 
    Para ver la diferencia de nomenclaturas:
        PascalCase
        camelCase    
        snake_case
        kebab-case

26. ESTILOS en react:
    Se pueden importar archivos css
    También podemos usar estilos en línea, pero en lugar de ponerlos como un string debemos hacerlo como un objeto:
    Ej.
        <article style={{ display: 'flex', alignItems: 'center'}}></article>
    Lo correcto es usar importacion de archivos css, pero a veces no se puede y hay que usar los estilos en línea. 
    También en react native habrá que usar estilos en línea.

27. IMPORTANTE: para determinar o indicar la clase en un elemento debemos utilizar className, puesto que class es una palabra reservada de Javascript.

28. Para los estilos podemos usar BEM o SUIT. Puedes aplicar CSS Modules

29. IMPORTANTE: existe una web con componentes de react ya creados y estilados: chakra-ui.com

30. IMPORTANTE: un componente será reutilizable si podemos pasarle propiedades o parámetros para poder adaptarlo a nuestra necesidad. Si no tienen parámetros no es reutilizable, siempre será único.

31. IMPORTANTE: Para devolver más de un elemento en react tenemos que utilizar el React.Fragment envolviéndolos, pero existe un atajo:
        <> ...elementos... </>   es lo mismo que poner <React.Fragment> ...elementos... </React.Fragment>

32. Cuando estilamos hay que tener presente que no pongamos estilos para arreglar un componente en el contexto actual pero que en otro contexto no quedaría bien, por ejemplo un margin-top de un elemento.
    Para eso es mejor estilar el componente padre, o hacerlo de manera que siempre se vea bien.

33. IMPORTANTE: para pasar un parámetro booleano a un componente:
    1. Si le pasamos "true" lo interpreta como un string que escribe true no como booleano.
    2. Hay que interpretarlo poniendolo entre llaves: {true}
        Ej.
            <TwitterFollowCard
                key="key"
                userName="nombre"
                initialIsFollowing={false}
                >
                "Nombre"
            </TwitterFollowCard>
    3. Podemos ahorrarnos las llaves si le pasamos directamente una variable booleana
        Ej.
            <TwitterFollowCard
                key="key"
                userName="nombre"
                initialIsFollowing
                >
                "Nombre"
            </TwitterFollowCard>
    4. No podemos pasarle un negado de una variable booleana.
        Ej.
            <TwitterFollowCard
                key="key"
                userName="nombre"
                !initialIsFollowing
                >
                "Nombre"
            </TwitterFollowCard>
        Esto da error, hay que pasarle el {false}

34. IMPORTANTE: también podemos pasarle funciones como props o parámetros al componente. Las funciones en javascript son de primera clase, con lo que podemos pasarlas como parámetros.
    OJO: no es lo mismo pasar la función que pasar la ejecución de la función. Para pasar la ejecución es miFuncion = {funcionName()} mientras que para pasar la función es miFuncion = {funcionName}
    donde funcionName es el nombre de la función.

35. **> CLAVE <** ==>>  ¿ cuál es la diferencia entre un ELEMENTO y un COMPONENTE ?: un componente es como una factoría de elementos, es una función que al ejecutarla te devuelve un elemento.

36. IMPORTANTE: las props deberían ser inmutables => no debemos modificar el valor de las props dentro del componente. Lo correcto es hacer una copia en una constante o variable y luego modificarla.

37. **> CLAVE <** ==>> CHILDREN: es una prop especial que hace referencia a todos los hijos de un elemento, pueden ser uno o varios.
    Ej.
        <TwitterFollowCard
            key={userName}
            userName={userName}
            initialIsFollowing={isFollowing}
            >
            {name}                  -> esto sería el children
        </TwitterFollowCard>

    En el componente podemos acceder a la prop como children:
    Ej.
        export function TwitterFollowCard ({ children, userName, initialIsFollowing }) {
            const [isFollowing, setIsFollowing] = useState(initialIsFollowing)

            console.log('[TwitterFollowCard] render with userName: ', userName)

            const text = isFollowing ? 'Siguiendo' : 'Seguir'
            const buttonClassName = isFollowing
                ? 'tw-followCard-button is-following'
                : 'tw-followCard-button'

            const handleClick = () => {
                setIsFollowing(!isFollowing)
        }

        return (
            <article className='tw-followCard'>
            <header className='tw-followCard-header'>
                <img
                className='tw-followCard-avatar'
                alt='El avatar de midudev'
                src={`https://unavatar.io/${userName}`}
                />
                <div className='tw-followCard-info'>
                <strong>{children}</strong>
                <span className='tw-followCard-infoUserName'>@{userName}</span>
                </div>
            </header>

            <aside>
                <button className={buttonClassName} onClick={handleClick}>
                <span className='tw-followCard-text'>{text}</span>
                <span className='tw-followCard-stopFollow'>Dejar de seguir</span>
                </button>
            </aside>
            </article>
            )
        }
        
    En ese caso es un texto el contenido de children con el nombre.

38. IMPORTANTE: normalmente lo más importante de un componente que además quieres que sea extensible y modificable al máximo debería ser un children.
    No indicar children como un paso de prop normal, solo hace falta ponerlo en el componente no en el paso de parámetros, puesto que ya tienen entidad por sí sola.

39. Se pueden pasar todas las props en un objeto mediante Rest Operator:
    Ej.
        const midu = {isFollowing: false, userName: 'midudev'}
        const ferap = {isFollowing: true, userName: 'ferap'}

        return (
            <section className="App"
                <TwitterFollowCard
                        {...midu}
                    >
                    Miguel Angel
                </TwitterFollowCard>
                <TwitterFollowCard
                        {...ferap}
                    >
                    Pedro Santos
                </TwitterFollowCard>
            </section>
        )

    IMPORTANTE: no es una buena práctica porque puedes enviar información innecesaria y porque puedes provocar que el componente se renderice sin necesidad. Además suele ser menos claro. Solo en determinados casos puede darse por bueno.

40. ESTADO: foto del entorno y sus valores en un momento dado. 

41. HOOK: te permiten añadir cierta funcionalidad a tus componentes. Utilidades de React para dotar de funcionalidad en el renderizado a tus componentes.

42. Añadir un estado a un componente:
    Ej.
        const [isFollowing, setIsFollowing] = useState(initialIsFollowing)    -> donde lo inicializamos con initialIsFollowing
            isFollowing    -> es el estado o nombre de la variable que lo contiene
            setIsFollowing -> es la función que permite modificar ese estado 

    IMPORTANTE: este estado es INTERNO, está a nivel del componente.

43. IMPORTANTE: se llama React por su capacidad de reacción cuando hay un cambio de estado lo refleja en la UI renderizando las partes que hagan falta.

44. DOM Virtual: React solo cambia la parte necesaria para que el renderizado muestre los cambios de estado, lo hace de manera quirúrjica. Para ello React hace una foto de lo que hay renderizado en pantalla (DOM) y cuando se produce
    un cambio de estado busca las diferencias con el nuevo renderizado, este nuevo renderizado se genera en memória en forma de arbol antes de pintarlo (Virtual DOM) y entonces actualiza solo las partes que han cambiado comparando el DOM y el Virtual DOM. 
    REACT renderiza el contenido de forma automática en 2 casos:
        1. Cuando ha cambiado el estado interno de algún componente. 
        2. Cuando un componente padre se vuelve a renderizar y propaga los cambios hacia abajo. Cuando se renderiza un componente se renderizan todos los componentes que hay debajo o implicados en su renderizado.
            Esto pasa por tener estructura de árbol, solo se renderizan los hijos del componente que ha modificado su estado y él mismo, no los padres.        
    **> CLAVE <** ==>>  se renderizan de nuevo TODOS los componentes hijo del padre que ha cambiado el estado, aunque no sufran cambios concretos dichos componentes hijo. PERO, cuando React va a renderizar el componente, padre con sus hijos solo
    renderiza o pinta los cambios, por lo que los componentes hijos que no han modificado su html no se pintan de nuevo, aunque se han ejecutado dichos componentes para generar el html de renderizado de nuevo.
    No sobreescribe el DOM, lo deja intacto. Este proceso se hace comparando el DOM con el Virtual DOM y se llama RECONCILIATION.

45. **> CLAVE <** ==>> OPTIMIZACIONES: una optimización consiste en evitar que si ciertos componentes hijos no han cambiado nada no se rendericen ni ejecuten sus códigos aunque se modifique el componente padre.

46. De hijos a padres no podemos pasar props, pero podemos pasar callbacks.

47. No hay un hook para manejar el localStorage, pero como es javascript podremos crear nuestros propios hooks para eso y otras cosas.

48. Los comentarios de toda la vida de javascript se pueden incorporar en un componente react:  // comentario,  /* comentarios */
    Pero dentro de la parte de render (return()) del componente tendremos que utilizar { /* comentarios */ }  para que lo interprete, sino lo pondría como renderizado en pantalla.
    No suele ser buena práctica poner comentarios dentro del render.

49. Inicializamos los valores del estado en ocasiones si ya tienen valor previo a la entrada al componente con props, que se llamarán:  initialIsFollowing. 
    Ej.
        export function TwitterFollowCard ({ children, userName, initialIsFollowing }) {
            const [isFollowing, setIsFollowing] = useState(initialIsFollowing)

50. **> CLAVE <** ==>> Las props que se usan para inicializar un estado en un componente solo se aplican una vez, luego ya no se vuelven a usar aunque cambiemos su valor. Solo sirven para inicializar el estado la primera vez que renderizamos el componente.
    Por lo que no sirve tener un estado en el componente padre y pasárselo a los hijos como prop de initialIsFollowing pretendiendo que se actualicen los estados de los hijos. 

51. Utilizamos el componente para renderizar una lista de usuarios: como es javascript podemos usar un map de los usuarios y con eso ya lo tendríamos. Envolvemos entre llaves lo que queremos renderizar del componente padre:
    Ej.
        import { TwitterFollowCard } from './TwitterFollowCard.jsx'

        const users = [
        {
            userName: 'midudev',
            name: 'Miguel Ángel Durán',
            isFollowing: true
        },
        {
            userName: 'pheralb',
            name: 'Pablo H.',
            isFollowing: false
        },
        {
            userName: 'PacoHdezs',
            name: 'Paco Hdez',
            isFollowing: true
        },
        {
            userName: 'TMChein',
            name: 'Tomas',
            isFollowing: false
        }
        ]

        export function App () {
        return (
            <section className='App'>
            {
                users.map(({ userName, name, isFollowing }) => (
                <TwitterFollowCard
                    key={userName}
                    userName={userName}
                    initialIsFollowing={isFollowing}
                >
                    {name}
                </TwitterFollowCard>
                ))
            }
            </section>
        )
        }

52. IMPORTANTE: cuando renderizamos una lista o mapeo de elementos debemos indicar la KEY de cada uno de ellos o nos saldrá un warning en el explorador. Esto es porque así react puede identificar 
    cada elemento del array cuando hace sus comparaciones con el DOM Virtual y el DOM. Este valor de la Key es y debe ser único. El index puede usarse como Key si sabemos que cada elemento tiene siempre 
    el mismo índice, si van cambiando pueden darse problemas de rendering. El valor de la Key debe ser algo único de ese elemento.
    OJO: usar key = {Math.random()} no tiene sentido, porque cada vez que se renderice tendremos un valor diferente para el mismo elemento.
    Un Date.now tampoco sirve, ni en general nada aleatorio. Debe ser único para cada elemento. Con el Date.now() podemos tener duplicados y producirse duplicación de elementos renderizados.
    Con el Math.random() puede ser que funcione el render, pero tendremos un problema de rendimiento ya que renderizará todos los elementos.

---------------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------------



Curso de React desde cero: Crea un videojuego y una aplicación para aprender useState y useEffect
https://www.youtube.com/watch?v=qkzcjwnueLA
---------------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------------

53. Si modificas cualquier variable de estado debes hacerlo con su correspondiente función, sino react no sabrá que tiene que renderizar el componente afectado y sus hijos.
    Ej.
        // actualizar el tablero
        const newBoard = [...board]  => hacemos una copia para poder modificar el tablero sin tocar el original
        newBoard[index] = turn       => lo modificamos en la copia
        setBoard(newBoard)           => cambiamos el estado con las modificaciones en el original

54. Para evitar que nos deje modificar un valor ya existente en el tablero:
    Ej.
        // no actualizamos esta posición
        // si ya tiene algo
        if (board[index]) return

55. CAMBIO de ESTADO: el cambio de estado en react es asíncrono, y puede por lo tanto tardar más que el alert.
    Ej.
        // revisar si hay ganador
        const newWinner = checkWinnerFrom(newBoard)
        if (newWinner) {
            setWinner(newWinner)
            alert(`el ganador es ${newWinner}`)  =>  OJO se pintará el alert en pantalla conforme has ganado pero no verás el último movimiento del usuario en pantalla, porque la actualización de los estados es asíncrona
        }

    Por eso usamos los valores a futuro para validaciones de cosas que ya ha hecho el usuario, pero que el estado todavía no regleja.

56. Para poder resetear y volver a empezar de nuevo el juego basta con asegurar de volver a tener los estados como al principio del juego.
    Ej.
        const resetGame = () => {
            setBoard(Array(9).fill(null))
            setTurn(TURNS.X)
            setWinner(null)
        }

57. Para chequear si hemos terminado el juego sin ganador:
    Ej.
        export const checkEndGame = (newBoard) => {
            // revisamos si hay un empate
            // si no hay más espacios vacíos
            // en el tablero
            return newBoard.every((square) => square !== null)    => si no existe ningun null es que hemos completado el tablero
        }

58. Los hooks de useState no deben meterse dentro de un if porque react pierde las posiciones de los mismos y necesita tenerlas. No pueden estar dentro de lógica que cambie su
    posición en el componente, esta debe ser unívoca y clara para react.

59. Guardar el estado de la partida en localStorage:
    Ej.
        export const saveGameToStorage = ({ board, turn }) => {
            // guardar aqui partida
            window.localStorage.setItem('board', JSON.stringify(board))
            window.localStorage.setItem('turn', turn)
        }

60. Recuperar el estado de la partida guardado y si existe inicializar el estado de la misma:
    Ej.
        const [board, setBoard] = useState(() => {
            const boardFromStorage = window.localStorage.getItem('board')
            if (boardFromStorage) return JSON.parse(boardFromStorage)
            return Array(9).fill(null)
        })
    No podemos condicionar como hemos dicho en el punto 58 el hook, pero podemos condicionar el valor que inicializamos.

    **> CLAVE <** ==>> la lectura del localStorage es lenta y debemos evitar hacerla si no es necesario. Si la ponemos dentro del useState del board solo se hará en los casos en que se 
    inicialice el tablero, pero si la ponemos justo antes lo hará cada vez que se renderice el componente.

    Lo mismo hacemos con los turnos:
    Ej.
        const [turn, setTurn] = useState(() => {
            const turnFromStorage = window.localStorage.getItem('turn')
            return turnFromStorage ?? TURNS.X
        })

61. Hay que acordarse de resetear los valores del localStorage cuando reseteamos el juego:
    Ej.
        const resetGame = () => {
            setBoard(Array(9).fill(null))
            setTurn(TURNS.X)
            setWinner(null)

            resetGameStorage()
        }

62. useEffect: es un hook que nos permite ejecutar código arbitrario cuando el componente se monta en el DOM y cada vez que cambian las dependencias que nosotros le indicamos
    Ej.
        useEffect(() => {
            document.body.classList.toggle('no-cursor', enabled)

            return () => {
            document.body.classList.remove('no-cursor')
            }
        }, [enabled])

    Tiene como parámetros una función y luego una lista opcional de valores sobre los que ejercerá el control y en caso de cambiar ejecutará la función. También ejecutará la función al 
    montar el componente donde esté.

    Si la lista de valores no está informada la función se ejecutará cada vez que se renderice el componente.

    Si la lista de valores está vacía [] se ejecutará solo la primera vez que se renderice el componente.

    Cuando informamos valores en la lista es como suscribirse a un evento. Se ejecutará siempre que pase.

    **> CLAVE <** ==>> usamos el useEffect para cargar listeners o apis de terceros que no tiene sentido que se ejecuten cada vez que se renderice el componente, así lo ejecutaremos cuando queramos.

    No permiten parámetros las funciones useEffect.

63. **> CLAVE <** ==>> Requisitos para instalar en los proyectos:
    1. npm install standard -D      => son reglas de linter 
    2. En el package.json aparcerá el standard recien instalado, y añadiremos lo siguiente:
        Ej. 
            "devDependencies": {
                "standard": "17.0.0"
            },
            "eslintConfig": {
                "extends": "./node_modules/standard/eslintrc.json"
            }
    3. Instalamos la extensión de eslint en el visual studio code
    Ahora cuando abrimos una página nos salen advertencias de posibles errores de sintaxis, espacios, comillas, lineas, ... Al guardar si tenemos activado el corrector automático o editor automático nos lo 
    corregirá automáticamente.

64. Proyecto para que una animación siga al puntero por la pantalla:
    Ej. 
        // pointer move
        useEffect(() => {
            console.log('effect ', { enabled })

            const handleMove = (event) => {
            const { clientX, clientY } = event
            setPosition({ x: clientX, y: clientY })
            }

            if (enabled) {                                          => importante, solo añadimos el listener si esta activo el enabled
                window.addEventListener('pointermove', handleMove)
            }

            // cleanup:
            // -> cuando el componente se desmonta
            // -> cuando cambian las dependencias, antes de ejecutar
            //    el efecto de nuevo
            return () => { // cleanup method
                console.log('cleanup')
                window.removeEventListener('pointermove', handleMove)           => **> CLAVE <** ==>> CLEAN useEffect: las suscripciones las tenemos que limpiar, 
            }                                                                                 porque persisten en el tiempo, react no las cancela
        }, [enabled])

    **> CLAVE <** ==>> no podemos meter el useEffect en el condicional  if(enabled)   ni en ningún otro por lo que habíamos dicho de la posición de los hook en react.

    Es buena práctica inicializar con valores siempre que podamos, sino con null.
    Ej.
        const [position, setPosition] = useState({ x: 0, y: 0 })

    
65. **> CLAVE <** ==>> CLEAN useEffect: las suscripciones las tenemos que limpiar, porque persisten en el tiempo, react no las cancela. ¿Cuando hacer esas limpiezas? pues en el return() 
    que podemos indicar para las funciones useEffect. Podemos declarar una función que haga estas limpiezas.
    Ej.
        return () => { // cleanup method
            console.log('cleanup')
            window.removeEventListener('pointermove', handleMove)           
        }        

    ¿Cuando se ejecuta este return? 
        1. Siempre que se desmonte el componente
        2. Cada vez que cambien las dependencias de la función useEffect -> se ejecuta antes del propio useEffect, realiza una limpieza previa antes del nuevo efecto.

66. **> CLAVE <** ==>> Si no limpiamos las suscripciones en las funciones useEffect no solo tendremos un problema de funcionamiento, sino que se irán creando nuevas suscripciones ocupando 
    recursos y penalizando el rendimiento del app.

67. **> CLAVE <** ==>> Si queremos saber cuantas suscripciones se han realizado a un determinado evento en el chrome podemos ir a Consola y poner: getEventListeners(window)
    Nos indicará un array con las suscripciones a cada evento en caso de existir más de una. Con esto podremos ver si estamos limpiando bien los eventos. También sirve para
    determinar problemas de rendimiento en páginas web.

68. React.StrictMode: se utiliza para que te de avisos si estás haciendo algo incorrecto, si estás utilizando react antiguo, y tiene una particularidad al montar los componentes: 
    ejecuta el efecto del componente, ejecuta el cleanup del mismo componente y luego vuelve a ejecutar el efecto del componente. Esto solo pasa en desarrollo, y ejecuta entonces
    2 veces los componentes. Es una ayuda para detectar malos funcionamientos en desarrollo. El React.StrictMode en producción lo ignora y es como si no existiera. En desarrollo 
    si quisieramos podemos quitarlo y dejará de hacer el doble ejecutor.

69. **> CLAVE <** ==>> React Developer Tools: son unas herramientas de desarrollo para cualquier explorador de windows de los más conocidos.
    Una vez instalada nos indicará en un inconito superior derecho si estamos en desarrollo o producción, el primer caso aparece en rojo con un escarabajo de debug.
    Si miramos al final hay 2 nuevas opciones: 
        1. Profiler:
            Ejecutamos nuestra aplicación después de darle a grabar en Profiler y luego miramos en profiler, podremos ver temas de rendimiento. Le tenemos que dar a grabar y despues de parar 
            la grabación podremos estudiar el comportamiento de nuestra app web. Indicando las renderizaciones y qué las ha causado. 
        2. Components:
            Los nombres de los componentes en producción normalmente están minificados, salvo que hubieran puesto el DisplayName.
            Pero en desarrollo lo veremos todo, y no solo los componentes, podremos ver sus props y estados y podremos cambiar sus valores. Veremos los hooks. Y como en html al hacer click sobre un
            componente lo seleccionarán en la pantalla del la web. Esto nos permite ver si modificamos el estado como responde nuestra UI.
            Es super potente porque te permite replicar situaciones en los cambios de estado por ejemplo que nos permetirá reproducir errores o momentos del web.
            Otra cosa interesante es que muestra el arbol de componentes completo del web. Los valores solo los permite cambiar en desarrollo.

70. Montar un useEffect para quitar / ocultar el mouse en pantalla:
    Ej.
        // change body className
        useEffect(() => {
            document.body.classList.toggle('no-cursor', enabled)

            return () => {
            document.body.classList.remove('no-cursor')
            }
        }, [enabled])

71. No es una buena práctica usar un solo useEffect para hacerlo todo, es mejor tener varios cada uno con su objetivo.

72. Dentro de Netlify tenemos app.netlify.com/drop que nos permite mediante arrastre de la carpeta dist creada por el npm run build. Si no nos registramos lo mantiene por 1 hora.


---------------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------------


Prueba Técnica de React para Juniors y Trainee
https://www.youtube.com/watch?v=XYpadB4VadY
---------------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------------

Vamos a hacer la prueba sin tener plantilla inicial de React, es decir creando un proyecto con Vite pero con Vanilla y luego lo transformamos a React.

73. creamos el proyecto Vanilla:
    Ej.
        npm create vite@latest
            react-prueba-tecnica
            Vanilla
            JavaScript

        cd react-prueba-tecnica

74. Instalamos un plugin de react
    Ej.
        npm install @vitejs/plugin-react -E
        code .

75. Tenemos la plantilla pero si abrimos el package.json vemos que no tenemos react ni sus dependencias. Las instalamos:
    Ej.
        npm install react react-dom -E
            donde react es la biblioteca de react que tiene los hooks y demás
            y react-dom es la que tiene los bindings con el navegador

76. Creamos el fichero vite.config.js o lo rellenamos con:
    Ej.
        import { defineConfig } from 'vite'
        import react from '@vitejs/plugin-react'

        export default defineConfig({
            plugins: [react()]
        })

77. **> CLAVE <** ==>> Creamos el punto de entrada de la aplicación de react (es crear el elemento raiz de la misma y poner el primer componente):
    Esto lo hacemos en nuestro main.js puesto que es el primer archivo que se carga a través de nuestro index.html
    Ej.
        import { createRoot } from 'react-dom/client'

        const root = createRoot(document.getElementById('app'))
        root.render(<h1>Hello, world!</h1>)    

    **> CLAVE <** ==>> Problema: este código no se ejecuta porque requiere la extensión .jsx para hacerlo transpilando el código con SWC o similar. Renombramos a main.jsx.
    También modificamos la referencia en index.html al nuevo archivo main.jsx

78. Instalamos el eslint:
    Ej.
        npm install standard -D

    Lo configuramos en el package.json añadiendo:
    Ej.
        ,
        "eslintConfig": {
            "extends": "./node_modules/standard/eslintrc.json"
        }

79. Creamos el Readme.md y añadimos la descripción de la prueba técnica:
    Ej.
        # Prueba técnica para Juniors y Trainees de React en Live Coding.

        APIs:

        - Facts Random: https://catfact.ninja/fact
        - Imagen random: https://cataas.com/cat/says/hello

        - Recupera un hecho aleatorio de gatos de la primera API y muestra una imagen de un gato con la primera palabra del hecho recuperado usando la segunda API.

80. Creamos el App.jsx dentro de mi src/Components
    Ej.
        export function App () {
            return (
                <h1>App de gatitos</h1>   
        )}

    Importamos el componente en nuestro main.jsx y lo llamamos en el cuerpo:
    Ej.
        import { createRoot } from 'react-dom/client'
        import { App } from './src/App.jsx'

        const root = createRoot(document.getElementById('app'))
        root.render(<App />)

81. **> CLAVE <** ==>> conforme vamos programando debemos ir mostrando cosas en la pantalla que demuestren nuestro progreso.

82. Definir la prueba en subtareas a realizar:
    - Recupera un hecho aleatorio de gatos de la primera API
    - Recuperar la primera palabra del hecho
    - Muestra una imagen de un gato con la primera palabra del hecho recuperado usando la segunda API.

    **> CLAVE <** ==>> concretar lo que devuelve la API y asegurar el endpoint que vamos a utilizar. Incluso lo pondríamos en una constante dentro de un template ya con las partes a cambiar:
        Ej.
            const CAT_ENDPOINT_RANDOM_FACT = 'https://catfact.ninja/fact'

83. Recuperamos el useState y creamos un estado fact:
    Ej.
        import {useState} from "react"

        export function App () {
            const {fact, setFact} = useState('lorem ipsum what the fact')

            **> CLAVE <** ==>> no podemos poner aquí un fetch de datos porque esto se ejecuta cada vez que renderizamos nuestro componente

            **> CLAVE <** ==>> Usamos un useEffect para que la primera vez que se va a montar nuestro componente haga el fecth

            **> CLAVE <** ==>> No olvidarse de poner la dependencia: []  o entraremos en bucle infinito y tendremos problemas 

            useEffect (() => {
                fetch('https://catfact.ninja/fact')
                    .then(res => res.json())
                    .then(data => setFact(data.fact))
            }, [])

            return (
                <main>
                    <h1>App de gatitos</h1>
                    {fact && <p>{fact}</p>}         // Usamos el renderizado condicional como algo que ya sabemos hacer
                </main>
        )}

    Un fetch devuelve una promesa que todavía no la tenemos en json, por lo que lo hacemos y después cambiamos el estado con los datos 
    
84. En useEffect si queremos poner async await debemos envolverlo:
    Ej.
        useEffect (() => {
            async function getRandomFact () {                
                const res = await fetch('https://catfact.ninja/fact')
                const json = await res.json()
                setFact(json.fact)                
            }

            getRandomFact()            
        }, [])

    **> CLAVE <** ==>> No podemos poner el async await directamente en el useEffect.

85. Justo despues de obtener el fact buscamos la primera palabra del mismo:
    Ej.
        const firstWord = fact.split(' ')[0]

    IMPORTANTE: si quieren que nos quedemos con las 3 primeras palabras:
        Ej.
            const firstWord = fact.split(' ').slice(0, 3).join(' ')
            el split obtiene un array con tantas palabras como tengamos.
            el slice obtiene las 3 primeras
            el join las une con espacios en una cadena de texto

    Una opción más óptima de este último caso es:
        Ej.
            const firstWord = fact.split(' ', 3).join(' ')

86. **> CLAVE <** ==>> para buscar cosas del lenguaje como la función para separar string por un token: 
    Ej. 
        en el buscador de google ponemos: mdn separar string por separador

87. **> CLAVE <** ==>> NO busquéis la solución a lo que os piden en google, buscar documentación de lo que necesitáis para resolverlo, pero no de ejemplos ya hechos.    

88. usamos la segunda API con nuestra primera palabra. Para guardarla necesitamos otro estado:
    Ej.
        onst [imageUrl, setImageUrl] = useState()

        useEffect (() => {
            fetch(`https://cataas.com/cat/says/${threeFirstWords}?size=50&color=red&json=true`)
                .then(res => res.json())
                .then(data => {
                    const {url} = data
                    setImageUrl(`https://cataas.com${url}`)       // esto funcionaría pero se puede hacer mejor -> punto 18
            })
        }, [])

89. Presentamos los datos obtenidos:
    Ej.
         return (
                <main>
                    <h1>App de gatitos</h1>
                    {fact && <p>{fact}</p>}         // Usamos el renderizado condicional como algo que ya sabemos hacer
                    {imageUrl && <img src={imageUrl} alt='Imágen extraida de la segunda API con 3 palabras de la primera API.' />}
                </main>
         )

    Poner el contenido del alt con un texto coherente que explique lo que hace la imagen

90. Razones por las que no poner en el estado la parte raiz de la url:
    Porque en el estado tenemos que tener lo mínimo posible, y esto lo podemos tener fuera.

91. Si os piden alinear al centro los componentes en pantalla:
    Dais estilos:
        En columna:  
        Ej.
            main {
                display: flex;
                flex-direction: column;
                place-items: center;           es lo mismo que poner justify-content: center; y align-items: center; juntos
                max-width: 800px;
                margin: 0 auto;
                font-family: system-ui;
            }
    
        Si lo queremos en fila: 

        Añadimos un section:
        Ej.
            return (
                <main>
                    <h1>App de gatitos</h1>
                    <section>
                        {fact && <p>{fact}</p>}         // Usamos el renderizado condicional como algo que ya sabemos hacer
                        {imageUrl && <img src={imageUrl} alt='Imágen extraida de la segunda API con 3 palabras de la primera API.' />}
                    </section>                    
                </main>
            )

        cambiamos los estilos:
        Ej.
            section {
                display: flex;
                justify-content: space-between;
                align-items: center;
                gap: 2rem;   
            }

            section img {
                max-width: 320px;
                height: auto;
            }

92. **> CLAVE <** ==>> los efectos en react debería tener una sola responsabilidad, si les damos varias no es una buena práctica.
    Esto distribuye las responsabilidades y evita la anidación.
    Ej.
        useEffect (() => {
            async function getRandomFact () {                
                const res = await fetch('https://catfact.ninja/fact')
                const json = await res.json()
                setFact(json.fact)                
            }

            getRandomFact()            
        }, [])

        useEffect (() => {
            if (!fact) return
            fetch(`https://cataas.com/cat/says/${threeFirstWords}?size=50&color=red&json=true`)
                .then(res => res.json())
                .then(data => {
                    const {url} = data
                    setImageUrl(`https://cataas.com${url}`)       // esto funcionaría pero se puede hacer mejor -> punto 18
            })
        }, [fact])

93. **> CLAVE <** ==>> los errores se pueden gestionar en el useEffect, pero hay que tener en cuenta que entraremos en el catch si hay errores con la petición, no con la
    respuesta. Esta la tenemos que controlar nosotros.
    Ej.
            useEffect (() => {
                fetch('https://catfact.ninja/fact')
                    .then(res => {
                        if (!res.ok) throw new Error('Error fetching fact')    // asi llegaremos al catch también si hay un error con la petición
                        return res.json()                        
                    )
                    .then(data => setFact(data.fact))
                    .catch((err) => {
                        // solo errores en la petición
                    })
            }, [])

94. Normalmente nos pedirán añadir un botón que al darle refresquemos la imagen o hagamos alguna acción sobre el componente:
    Ej.
        async function getRandomFact () {                
            const res = await fetch('https://catfact.ninja/fact')
            const data = await res.json()
            const { fact } = data
            return fact
        }

        **> CLAVE <** ==>> si separamos la lógica en funciones para poder reutilizarlas no es buena práctica pasar estados o funciones de modificación de estados de nuestro 
        componente a la función. Tiene que ser completamente reutilizable, lo que es react que se quede en el componente. Así si que podemos crearla en un archivo .js
        y luego importarla.

        useEffect (() => {
            getRandomFact().then(setFact)               **> CLAVE <** ==>> sería lo mismo que escribir: getRandomFact().then(newfact => setFact(newfact))     
        }, [])

        const handleClick = async () => {
            const newfact = await getRandomFact()
            setFact(newfact)            
        }

        <button onclick={handleClick}>Get new fact</button>

---------------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------------




Custom Hooks + Testing con Playwright: Curso de React desde cero - Parte 4
https://www.youtube.com/watch?v=x-LcbVw99o8
---------------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------------

95. **> CLAVE <** ==>> Un Custom Hook es simplemente extraer lógica de nuestros componentes para poder reutilizarla en otros componentes

96. Creación de un Custom Hook -> debemos crear una función que empiece con la palabra useXXXXXXXX seguida del resto del nombre 
    Ej.
        function useCatImage () {}

97. Uso del Custom Hook: 
    Ej.
        const prefijo = useCatImage()

98. En nuestro caso es más complejo, para tener la lógica que recupera la imagen del gato creamos un fichero useCatImage.js. No requieren de un .jsx porque no tienen. 
    Movemos dentro de la función la lógica de nuestro componente de react que ya estaba funcionando tal cual, con estado incluído:
    Ej.
        import { useEffect, useState } from 'react'

        const CAT_PREFIX_IMAGE_URL = 'https://cataas.com'

        export function useCatImage ({ fact }) {                                // los parámetros van entre llaves en este caso por buenas prácticas ver punto 101
            const [imageUrl, setImageUrl] = useState()

            // para recuperar la imagen cada vez que tenemos una cita nueva
            useEffect(() => {
                if (!fact) return

                const threeFirstWords = fact.split(' ', 3).join(' ')

                fetch(`https://cataas.com/cat/says/${threeFirstWords}?size=50&color=red&json=true`)
                .then(res => res.json())
                .then(response => {
                    const { _id } = response
                    const url = `/cat/${_id}/says/${threeFirstWords}`
                    setImageUrl(url)
                })
            }, [fact])

            return { imageUrl: `${CAT_PREFIX_IMAGE_URL}${imageUrl}` }
        }

99. Uso de nuestro custom hook:
    En el componente que lo va a utilizar ya podemos llamarlo y obtener la imagen:  
    Ej.
        const { imageUrl } = useCatImage({ fact })

    **> CLAVE <** ==>> Esta llamada no la podemos poner dentro de un if, ni un while ni en ninguno de los casos en que no se permite un hook, igual que cualquier hook de react.

100. **> CLAVE <** ==>> La diferencia entre un Custom Hook y una función normal radica en que en un Custom Hook se pueden usar hooks de react y en una función normal NO.

101. Pasando los parámetros entre llaves los estamos pasando como un objeto, con esto favorecemos la extensibilidad de nuestra función. Si en el futuro añadimos nuevos parámetros a la
    función simplemente los añadimos al objeto separándolos por comas, y el orden es indiferente en el paso del parámetro. Además el nombre de cada elemento del objeto tiene que ser el que
    hemos requerido en nuestra función mientras que en un parámetro normal podemos poner el nombre que queramos al parámetro que pasamos. Ganamos claridad, y facilidad de extensibilidad 
    haciéndolo con un objeto.

102. IMPORTANTE: evitar darle un nombre al custom hook que te diga en que está basada la implementación, ej. useFetchCat.  Tienen que ser una caja negra independiente de la implementación.

103. Hacemos otro custom hook en nuestro proyecto para recuperar la cita en la página. Creamos el fichero useCatFact.js y ponemos:
    Ej.
        import { useState, useEffect } from 'react'
        import { getRandomFact } from '../services/facts.js'

        export function useCatFact () {
            const [fact, setFact] = useState()          // su estado interno

            const refreshFact = () => {
                getRandomFact().then(newFact => setFact(newFact))       // llama a la función que hace el fetch a nuestra API y luego asigna el estado con el resultado
            }

            // para recuperar la cita al cargar la página
            useEffect(refreshFact, [])                      // ejecuta la función refreshFact cada vez que se monta el componente

            return { fact, refreshFact }    **> CLAVE <** ==>> como en el botón del App.jsx tenemos que hacer lo mismo que hace refreshFact la devolvemos también.
        }

    Donde la función getRandomFact estaría definida en el fichero fact.js como:
    Ej.
        const CAT_ENDPOINT_RANDOM_FACT = 'https://catfact.ninja/fact'

        export const getRandomFact = async () => {
            const res = await fetch(CAT_ENDPOINT_RANDOM_FACT)
            const data = await res.json()
            const { fact } = data
            return fact
        }

    Para usarlo en nuestro App.jsx ponemos:
    Ej.
        import './App.css'
        import { useCatImage } from './hooks/useCatImage.js'
        import { useCatFact } from './hooks/useCatFact.js'

        export function App () {
        const { fact, refreshFact } = useCatFact()
        const { imageUrl } = useCatImage({ fact })      // IMPORTANTE: esta línea no puede ir delante de la que utiliza useCatFact para definir nuestro fact

        const handleClick = async () => {
            refreshFact()                   // IMPORTANTE: hemos reutilizado una llamada a una función interna a nuestro hook que actualiza o modifica el estado interno del mismo sin exportar el propio setFact,
                                                            es mejor que lo haga el custom hook internamente
        }

        return (
            <main>
            <h1>App de gatitos</h1>

            <button onClick={handleClick}>Get new fact</button>

            {fact && <p>{fact}</p>}
            {imageUrl && <img src={imageUrl} alt={`Image extracted using the first three words for ${fact}`} />}
            </main>
        )
        }  

104. **> CLAVE <** ==>> siempre que veamos un useEffect y otros casos hay que preguntarse si no valdría la pena tenerlo en un custom hook. Porque sería lógica reutilizable que tendríamos fuera de nuestro componente.

105. **> CLAVE <** ==>> si nos dicen que más haríamos si tenemos tiempo: 
        1. Control de errores en nuestros componentes.
        2. Testing del app.

106. Test básico: 
    Instalamos un testeador: npm init Playwright@latest
        Indicamos JavaScript
        carpeta tests
        NO al añadir Github actions
        SI a Instalar Playwright browser

    Nos habrá creado un ejemplo en la carpeta tests. Lo modificamos con nuestro test:
    Ej.
        // @ts-check
        import { test, expect } from '@playwright/test'       // OJO: si al ejecutar da error puede ser que estemos utilizando EMACS y no admita los Required del playwright, habrá que modifcarlos por imports como en este caso.

        const CAT_PREFIX_IMAGE_URL = 'https://cataas.com'
        const LOCALHOST_URL = 'http://localhost:5173/'

        test('app shows random fact and image', async ({ page }) => {
        await page.goto(LOCALHOST_URL)

        const text = await page.getByRole('paragraph')     // recuperamos un párrafo de nuestra página, pilla el primero
        const image = await page.getByRole('img')          // recuperamos una primera imagen, como solo gat una ya nos vale 

        const textContent = await text.textContent()
        const imageSrc = await image.getAttribute('src')

        await expect(textContent?.length).toBeGreaterThan(0)                            // exige que tengamos un texto con contenido
        await expect(imageSrc?.startsWith(CAT_PREFIX_IMAGE_URL)).toBeTruthy()           // exige que tengamos una imagen válida de alguna forma
        })

    Ejecutamos el test:
    Ej.
        npx playwright test
        ... 1 passed (1.4s)

    

---------------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------------




Aprende a pasar una Prueba Técnica de React. Entiende useMemo, useCallback y useRef
https://www.youtube.com/watch?v=GOEiMwDJ3lc
---------------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------------

Prueba: Crea una aplicación para buscar películas

API a usar: - https://www.omdbapi.com/
Consigue la API Key en la propia página web registrando tu email.

Requerimientos:

✅ Necesita mostrar un input para buscar la película y un botón para buscar.

✅ Lista las películas y muestra el título, año y poster.

✅ Que el formulario funcione

✅ Haz que las películas se muestren en un grid responsive.

✅ Hacer el fetching de datos a la API

Primera iteración:

✅ Evitar que se haga la misma búsqueda dos veces seguidas.

✅ Haz que la búsqueda se haga automáticamente al escribir.

✅ Evita que se haga la búsqueda continuamente al escribir (debounce)


RESULTADO:

107. Creamos el proyecto con VITE: 
    Ej.
        npm create vite@latest
        cd 05-react-buscador-peliculas
        npm install
        code .
    
108. En el placeholder de un input no se pone un mensaje: escribe aquí tu película...  es más correcto poner un ejemplo de lo que pondrías: ej. Avengers, Matrix, ...
    
109. Ir a la API y mirar si hay una api que nos permita buscar. Probarla y mirar el resultado. Conesto sabremos lo que vamos a tener que tratar. No usar Console.log para ver el resultado,
    ni empezar a desarrollar sin haber visto lo que devuelve y requiere la llamada a la API.

    Probar también a buscar algo que no existe y ver que devuelve. 
    Crear mocks de estas respuestas para tenerlas en nuestro proyecto sin necesidad de API.
    Dentro del directorio mocks creamos: no-results.json y with-results.json.

110. Ya podemos mostrar y trabajar en los datos de la web sin tener el fetch, simplemente importando los mocks:
    Ej.
        import withResults from '.mocks/with-results.json'
        import withoutResults from '.mocks/no-results.json'
    
    Ahora podemos acceder a los objetos json y podremos ver los campos / tipos de que constan, asi como comprobar si tenemos datos y hacer un renderizado condicional.

111. Es una mala práctica hacer esto:
    Ej.
        const renderMovies = () => {
            return (
                <ul>
                    {
                        movies.map( movie => (
                            <li key={movie.imdbID}>
                                <h3>{movie.Tittle}</h3>
                                <p>{movie.Year}</p>
                                <img src={movie.Poster} alt={movie.Title} />
                            </li>
                        ))
                    }
                </ul>
            )
        }

        <main>
            {
                hasMovies 
                    ? renderMovies()
                    : renderNoResults()
            }
        </main>

    La razón es porque ese renderizado debería ser un componente react!

112. Creamos un componente de Movies:
    Ej.
        function ListOfMovies ({ movies }) {
            return (
                <ul className='movies'>
                {
                    movies.map(movie => (
                    <li key={movie.imdbID}>
                        <h3>{movie.Title}</h3>
                        <p>{movie.Year}</p>
                        <img src={movie.Poster} alt={movie.title} />
                    </li>
                    ))
                }
                </ul>
            )
        }

        function NoMoviesResults () {
            return (
                <p>No se encontraron películas para esta búsqueda</p>
            )
        }

        export function Movies ({ movies }) {
            const hasMovies = movies?.length > 0

            return (
                hasMovies
                ? <ListOfMovies movies={movies} />
                : <NoMoviesResults />
            )
        }

113. OJO, no es una buena práctica utiliza los atributos tal cual están en la API, quedamos muy expuestos a cambios del API, es mejor usar un mapped:
    Ej.
        const mappedMovies = movies?.map(movie => ({
            id: movie.imdbID,
            title: movie.Title,
            year: movie.Year,
            poster: movie.Poster
        }))

    De esta forma si cambia la firma de la API solo tendremos que tocar en este sitio para adaptarlo.

    Modificamos la función: 
    Ej.
        function ListOfMovies ({ movies }) {
            return (
                <ul className='movies'>
                {
                    movies.map(movie => (
                    <li key={movie.id}>
                        <h3>{movie.title}</h3>
                        <p>{movie.year}</p>
                        <img src={movie.poster} alt={movie.title} />
                    </li>
                    ))
                }
                </ul>
            )
        }

114. Creamos un Custom Hook para todo lo de los movies:
    Ej.
        import { useRef, useState } from 'react'
        import { searchMovies } from '../services/movies.js'

        export function useMovies () {
            const movies = responseMovies.Search

            const mappedMovies = movies?.map(movie => ({
                id: movie.imdbID,
                title: movie.Title,
                year: movie.Year,
                poster: movie.Poster
            }))
        
        return { movies: mappedMovies }
        }

        function App () {
            const {movies} = useMovies()

            return (
                ...
                <main>
                    <Movies movies={movies} />
                </main>        
            )
        }

115. **> CLAVE <** ==>> Nuevo Hook useRef: te permite crear una referencia a un elemento del DOM, esta sería una explicación mala. En realidad es un hook que te permite crear una
    referencia mutable que persiste durante todo el ciclo de vida de tu componente. Puedes guardar un contador y cada vez que cambie no vuelve a renderizar el componente como
    con el useState. El useState cada vez que cambia renderiza el componente, pero en cambio el useRef no renderiza el componente al cambiar el valor.
    Por esto es útil para guardar una referencia a un elemento del DOM y siempre lo tendremos accesible.
    Ej.
        const inputRef = useRef()

        const handleClick = () => {
            const inputEl = inputRef.current
            const value = inputEl.value
            console.log(value)
        }

        return (
            <div className='page'>
                <header>
                    <h1>Buscador de películas</h1>
                    <form className='form'>
                        <input
                            ref={inputRef}
                            placeholder='Avengers, Star Wars, The Matrix...'
                        />
                        <button onclick={handleClick} type='submit'>Buscar</button>
                    </form>
                </header>

                <main>
                    <Movies movies={movies} />                
                </main>
            </div>
        )

    Por ejemplo si en un componente ponemos:
    Ej.
        const current = useRef(0)       => es un valor que persiste entre renders
        counter.current++
        console.log(counter.current)

    En este caso veríamos que al renderizarse el componente se aumentaría el valor escrito, sería un contador de renderizados. A pesar de la inicialización a 0.
    Por ejemplo con una variable normal no pasaría:
        let i = 0
        i++ 
        console.log(i)      => siempre que se renderice pintará 1

116. No es una buena práctica aunque funciona hacer un handleClick de un botón tipo submit, es mejor hacer una handleSubmit asociado a ese botón.
    Ej.
        const inputRef = useRef()

        const handleSubmit = (event) => {
            event.preventDefault
            const inputEl = inputRef.current
            const value = inputEl.value
            console.log(value)
        }

        return (
            <div className='page'>
                <header>
                    <h1>Buscador de películas</h1>
                    <form className='form' onSubmit={handleSubmit}>
                        <input
                            ref={inputRef}
                            placeholder='Avengers, Star Wars, The Matrix...'
                        />
                        <button type='submit'>Buscar</button>
                    </form>
                </header>

                <main>
                    <Movies movies={movies} />                
                </main>
            </div>
        )

117. **> CLAVE <** ==>> Aunque no está mal hecho, es mejor práctica usar javascript de toda la vida para hacer lo mismo con FormData sobre el evento:
    Ej.
        const handleSubmit = (event) => {
            event.preventDefault
            const data = new window.FormData(event.target)   
            const query = data.get('query')         
            // aquí validamos los datos introducidos
            console.log(query)
        }

    Si hay muchos inputs podemos recuperarlos todos:
    Ej.
        const handleSubmit = (event) => {
            event.preventDefault
            const data = Object.fromEntries(new window.FormData(event.target))
            console.log(data)            
        }

        return (
            <div className='page'>
                <header>
                    <h1>Buscador de películas</h1>
                    <form className='form' onSubmit={handleSubmit}>
                        <input name='query'
                            placeholder='Avengers, Star Wars, The Matrix...'
                        />
                        <input
                            name='otro'
                            placeholder='Avengers, Star Wars, The Matrix...'
                        />
                        <input
                            name='otro2'
                            placeholder='Avengers, Star Wars, The Matrix...'
                        />
                        <button type='submit'>Buscar</button>
                    </form>
                </header>

                <main>
                    <Movies movies={movies} />                
                </main>
            </div>
        )

    No user el useRef para tener la referencia de muchos campos, es mejor hacerlo con javascript usando FormData 
    Ej.
        const { query } = Object.fromEntries(new window.FormData(event.target))   => como en el ejemplo anterior pero sabiendo que tenemos un objeto con el name query
    Esta es la primera de las 2 forma de gestionar un formulario, es la NO CONTROLADA POR REACT. Mediante el DOM, con un submit y demás. Es la forma más eficiente y rápida.
    En la forma NO CONTROLADA POR REACT también encontramos el required, pattern = '' en el Input de javascript, el onInvalid en el onSubmit, ...

118. SEGUNDA forma de gestionar un Form: CONTROLADA POR REACT:
    Vamos a crear un estado que controla los datos que escribimos en los inputs.
    Ej.
        const [query, setQuery] = useState('')
        const [error, setError] = useState(null)

        const handleChange = (event) => {
            setQuery(event.target.value)        => actualiza el estado con el nuevo valor que ha introducido el usuario
            
            // VALIDACIONES OPCION A
            // ojo no validar sobre el valor del estado query porque no garantizamos que se halla asignado al ser asíncrono
            // para ello asignamos el value del evento y validamos sobre el
            const newQuery = event.target.value
            if (newQuery == '') {
                setError('No se puede buscar una película vacía!')
                return
            }

            if (newQuery.match(/^\d+$/)) {
                setError('No se puede buscar una película con un número!')
                return
            }

            if (newQuery.length < 3) {
                setError('La búsqueda debe tener al menos 3 caracteres!')
                return
            }

            setError(null)
        }

        const handleSubmit = (event) => {
            event.preventDefault
            console.log({ query })              => ya tenemos el valor del input del usuario en el estado        
        }

        return (
            <div className='page'>
                <header>
                    <h1>Buscador de películas</h1>
                    <form className='form' onSubmit={handleSubmit}>
                        <input onChange={handleChange} name='query'
                            placeholder='Avengers, Star Wars, The Matrix...'
                        />
                        <input
                            name='otro'
                            placeholder='Avengers, Star Wars, The Matrix...'
                        />
                        <input
                            name='otro2'
                            placeholder='Avengers, Star Wars, The Matrix...'
                        />
                        <button type='submit'>Buscar</button>
                    </form>
                    {error && <p className='error'>{error}</p>}
                </header>

                <main>
                    <Movies movies={movies} />                
                </main>
            </div>
        )

    Esta forma CONTROLADA POR REACT tiene el inconveniente de que al cambiar el estado de valor fuerza la renderización de la pantalla o componente. Como ventaja tener el código más
    ordenado y no preocuparte del DOM para las validaciones que se pueden hacer de muchas maneras. Hay un hook que ayuda a paliar esta pérdida de eficiencia.
    Otra ventaja es que puedes hacer pre-validaciones en la forma Controlada de forma fácil mientras que en la forma controlada necesitarías mucho javascript para hacerlo.
    Ej.
        const handleChange = (event) => {
            const newQuery = event.target.value
            if (newQuery.startsWith(' ')) return    => si intentamos empezar con espacio no nos lo dejará hacer
            setQuery(newQuery)  
        }  
    En este caso evitamos que el estado se actualice y por lo tanto no se renderiza el componente.          

    De todas formas la forma NO CONTROLADA POR REACT es mucha más eficiente y podría ser la recomendada. 

    En la forma controlada puedes hacer las validaciones en el handleChange: VALIDACIONES OPCION A
    También podríamos usar un useEffect:
    Ej.
        useEffect ( () => {
            // VALIDACIONES OPCION B
            if (query == '') {
                setError('No se puede buscar una película vacía!')
                return
            }

            if (query.match(/^\d+$/)) {
                setError('No se puede buscar una película con un número!')
                return
            }

            if (query.length < 3) {
                setError('La búsqueda debe tener al menos 3 caracteres!')
                return
            }

            setError(null)
        }, [search])

    (se recomienda el uso de ZOT para este tipo de validaciones)

119. Lo mejor como siempre es dejar limpios nuestros componentes de lógica sacando toda como custom hook. 
    Ej.
        function useSearch () {
            const [search, updateSearch] = useState('')
            const [error, setError] = useState(null)
            const isFirstInput = useRef(true)           => uso del useRef como banderita para saber si es la primera vez que validamos o no 

            useEffect(() => {
                if (isFirstInput.current) {
                    isFirstInput.current = search === ''        => en cuanto el usuario teclee algo en el input dejará de ser cierto el useRef banderita
                    return
                }

                if (search === '') {
                setError('No se puede buscar una película vacía')
                return
                }

                if (search.match(/^\d+$/)) {
                setError('No se puede buscar una película con un número')
                return
                }

                if (search.length < 3) {
                setError('La búsqueda debe tener al menos 3 caracteres')
                return
                }

                setError(null)
            }, [search])

            return { search, updateSearch, error }
            }

            function App () {
            const [sort, setSort] = useState(false)
            const { search, updateSearch, error } = useSearch()

120. **> CLAVE <** ==>> otro uso del useRef consiste en evitar validaciones iniciales que se basan en los estados iniciales y no en las entradas del usuario.
    Ej.
        useEffect(() => {
            if (search === '') {
                setError('No se puede buscar una película vacía')
                return
            }   
        })     
    Este useEffect dará el mensaje de error de 'No se puede buscar una película vacía' nada más entrar porqué validará el contenido inicial vacío del estado de search.
    Para evitar esto se usa el useRef a modo de banderita como en el ejemplo anterior: const isFirstInput = useRef(true) 
    El valor lo chequeamos al principio del useEffect y en caso de ser cierto no hacemos nada, pero chequeamos si el usuario ha entrado algo en el input y cambiamos su valor
    a false en caso afirmativo. La ventaja es que el useRef no renderiza el componente de nuevo al cambiar el valor.

121. Sabemos que debemos usar un custom hook y no un helper típico de javascript cuando por un lado hay un useEffect en nuestro código a extraer. En general si hay algún hook
    en nuestro código lo mejor es usar un custom hook, sino usamos un helper de JS.

122. **> CLAVE <** ==>> GRID RESPONSIVE
    Ej.
        function ListOfMovies ({ movies }) {
            return (
                <ul className='movies'>
                {
                    movies.map(movie => (
                    <li className='movie'
                        key={movie.id}>
                        <h3>{movie.title}</h3>
                        <p>{movie.year}</p>
                        <img src={movie.poster} alt={movie.title} />
                    </li>
                    ))
                }
                </ul>
            )
        }     

    Estilos aplicados:
    Ej.
        .page {
            display:flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            max-width: 80rem;        
        }
        main {
            display: flex;
            justify-content: center;
            width: 100%;                    => importante si queremos que luego se muestre la grid
        }
        form {
            align-items: center;
            display: flex;
            justify-content: center;
        }
        .movies {
            list-style: none;
            margin: 0;
            padding: 0; 

            display: grid;
            width: 100%;
            grid-template-columns: repeat( auto-fit, minmax(20rem, 1fr) );  => se auto ocupa todo el espacio disponible con un mínimo de 20rem y si no puede se reparte con 1fr por película
            gap: 3.2rem;
        }   

        .movie {
            text-align: center;
        }        

        .movie h3, movie p {
            margin: 0;
        }

        .movi img {
            border-radius: 0.8rem;
            margin-top: 1.6rem;
        }

    IMPORTANTE: diferencias entre auto-fit y auto-fill
        	                        auto-fill	                                                            auto-fit
        🔁 Rellena con	    El mayor número de tracks posibles, incluso si están vacíos	            Solo tracks con contenido visible
        🪄 Espacios vacíos	  Reserva espacio para celdas vacías	                                 Colapsa celdas vacías
        ✅ Uso ideal	       Cuando quieres estructura constante	                        Cuando quieres que las celdas se expandan para ocupar espacio libre

123. IMPORTANTE: a los custom hook podemos pasarle parámetros
    Ej.
        export function useMovies ({ search }) {
            const [responseMovies, setResponseMovies] = useState([])

            const movies = responseMovies.Search

            const mappedMovies = movies?.map(movie => ({
                id: movie.imdbID,
                title: movie.Title,
                year: movie.Year,
                image: movie.Poster
            }))
            
            const getMovies = () => {
                if (search) {
                    setResponseMovies(withResults)
                }
                else {
                    setResponseMovies(withoutResults)
                }
            }

            return { movies: mappedMovies, getMovies }
        }

    Devuelve la función getMovies y el movies ya mapeados.

    La llamada desde el App sería:
    Ej.
        function App () {
            const { search, updateSearch, error } = useSearch()
            const { movies, getMovies } = useMovies({ search })

            ...
            return (
                ...
                <main>
                    <Movies movies={movies} />
                </main>        
            )
        }       

    Con esto tendríamos hecha la app sin hacer el fetch, tirando de nuestros json locales.

124. Hacemos el fetch:
    Ej.
        const getMovies = () => {
            if (search) {
                const response = await fetch(`https://www.omdbapi.com/?apikey=${API_KEY}&s=${search}`)
                const json = await response.json()

                const movies = json.Search

                // o con promesas

                fetch(`https://www.omdbapi.com/?apikey=${API_KEY}&s=${search}`)
                    .then( res => res.json )
                    .then( json => {
                        setResponseMovies(json)
                    })
            }
            else {
                setResponseMovies(withoutResults)
            }
        }

125. **> CLAVE <** ==>> miramos en nuestras herramientas de desarrollo si hemos hecho bien la llamada del fetch, ¿como? yendo a Network / Fetch/XHR y ahí veremos las llamadas 
    realizadas desde nuestra App. Le damos un click y veremos (pestaña Encabezados) por este orden si la URL que estamos llamando es la correcta (por ejemplo que se dirija a localhost y no a internet),
    el método utilizado para llamar (GET, POST, ...), si la respuesta que devuelve es la esperada: es un json con la pinta adecuada o no (pestaña Respuesta)

126. Extraemos la lógica del fetch a un servicio mejor que en un hook:
    Ej. 
        export const searchMovies = async ({ search }) => {
            if (search === '') return null

            try {
                const response = await fetch(`https://www.omdbapi.com/?apikey=${API_KEY}&s=${search}`)
                const json = await response.json()

                const movies = json.Search

                // hacemos el mapped movies en este servicio, no tiene porque estar en el custom hook
                return movies?.map(movie => ({          
                id: movie.imdbID,
                title: movie.Title,
                year: movie.Year,
                image: movie.Poster
                }))
            } catch (e) {
                throw new Error('Error searching movies')
            }
        }

    Ej.
        export function useMovies ({ search }) {
            const [movies, setMovies] = useState([])

            const getMovies = async () => {
                const newMovies = await searchMovies({ search })
                setMovies(newMovies)
            }

            return { movies, getMovies }
        }

    **> CLAVE <** ==>> para todo esto no hemos tocado nuestra App, solo el custom hook, que mientras cumpla el contrado de salida de { movies, getMovies } seguirá haciendo que nuestra App
    funcione correctamente.

127. Añadimos un control de carga y errores mediante estados en nuestro custom hook:
    Ej.
        export function useMovies ({ search }) {
            const [movies, setMovies] = useState([])
            const [loading, setLoading] = useState(false)
            // el error no se usa pero puedes implementarlo
            // si quieres:
            const [error, setError] = useState(null)

            const getMovies = async () => {
                try {
                    setLoading(true)
                    setError(null)
                    const newMovies = await searchMovies({ search })
                    setMovies(newMovies)
                } catch (e) {
                    setError(e.message)
                } finally {
                    // tanto en el try como en el catch
                    setLoading(false)
                }
            }

            return { movies, getMovies, loading }
        }

    En nuestra función principal ya podemos mostrar Cargando... o las películas cuando se hallan cargado:
    Ej.
        function App () {
            const { search, updateSearch, error } = useSearch()
            const { movies, getMovies, loading } = useMovies({ search })

            ...
            return (
                ...
                <main>
                    {loading ? <p>Cargando...</p> : <Movies movies={movies} />}
                </main>        
            )
        }       

128. **> CLAVE <** ==>> Uso de useRef para guardar el estado anterior. Podemos evitar que se vuelve a ejecutar la misma búsqueda que la última que hizo el usuario.
    Ej. 
        export function useMovies ({ search }) {
            const [movies, setMovies] = useState([])
            const [loading, setLoading] = useState(false)
            const [error, setError] = useState(null)
            const previousSearch = useRef(search)

            const getMovies = async () => {
                if (search == previousSearch.current) return
                try {
                    setLoading(true)
                    setError(null)
                    previousSearch.current = search
                    const newMovies = await searchMovies({ search })
                    setMovies(newMovies)
                } catch (e) {
                    setError(e.message)
                } finally {
                    // tanto en el try como en el catch
                    setLoading(false)
                }
            }

            return { movies, getMovies, loading }
        }

129. También se podría hacer con javascript definiendo el previousSearch con let fuera del cumtom hook, pero aunque funcionará no es buena práctica, ya que se compartiría
    esa misma variable en todos los usos del custom hook que utilizasemos. Es decir, el uso del custom hook no debería depender del import del archivo que lo incluye, ya que la
    importación es singletton y podríamos usar varias veces el useMovies en nuestro código.
    Ej.
        let previousSearch = ''

        export function useMovies ({ search }) {
            const [movies, setMovies] = useState([])
            const [loading, setLoading] = useState(false)
            const [error, setError] = useState(null)
            
            const getMovies = async () => {
                if (search == previousSearch.current) return
                try {
                    setLoading(true)
                    setError(null)
                    previousSearch.current = search
                    const newMovies = await searchMovies({ search })
                    setMovies(newMovies)
                } catch (e) {
                    setError(e.message)
                } finally {
                    // tanto en el try como en el catch
                    setLoading(false)
                }
            }

            return { movies, getMovies, loading }
        }

130. Creamos un estado para ordenar las peliculas por título:
    Ej.
        function App () {
            const { sort, setSort } = useState(false)
            const { search, updateSearch, error } = useSearch()
            const { movies, getMovies, loading } = useMovies({ search })

            const handleSort = () => {
                setSort(!sort)
            }

            ...
            return (
                <div className='page'>
                    <header>
                        <h1>Buscador de películas</h1>
                        <form className='form' onSubmit={handleSubmit}>
                            <input onChange={handleChange} value={search} name='query'
                                placeholder='Avengers, Star Wars, The Matrix...'
                            />
                            <input type='check' onChange={handleSort} value={sort}
                            <button type='submit'>Buscar</button>
                        </form>
                        {error && <p className='error'>{error}</p>}
                    </header>

                    <main>
                        {loading ? <p>Cargando...</p> : <Movies movies={movies} />}
                    </main>
                </div>
            )
        }       

    Pasamos al custom hook el sort como parámetro:
    Ej.
        export function useMovies ({ search, sort }) {
            const [movies, setMovies] = useState([])
            const [loading, setLoading] = useState(false)
            const [, setError] = useState(null)
            const previousSearch = useRef(search)

            const getMovies = async () => {
                if (search === previousSearch.current) return

                try {
                    setLoading(true)
                    setError(null)
                    previousSearch.current = search
                    const newMovies = await searchMovies({ search })
                    setMovies(newMovies)
                } catch (e) {
                    setError(e.message)
                } finally {
                    // tanto en el try como en el catch
                    setLoading(false)
                }
            }
            
            const sortedMovies = sort                                           => si tenemos chequeado el sort lo ordenamos sino no
                ? [...movies].sort((a, b) => a.title.localeCompare(b.title))    => el localCompare tiene en cuenta las tildes
                : movies            

            return { movies: sortedMovies, getMovies, loading }
        }

    Esto funciona, pero tiene un problema de rendimiento, porque no solo se aplica cuando el usuario da al buscar, también se renderiza de nuevo el componente el cambiar el texto del input
    de la búsqueda, provocando de nuevo la reordenación de las películas siendo innecesario.

    **> CLAVE <** ==>> en react el render es el cuerpo del componente, y en el caso de un custom hook es el cuerpo de la función. Todo lo que hay dentro se ejecutará de nuevo en caso de render.
    En un custom hook si cambiarmos el valor de un parámetro que recibe se entenderá como un renderizado del mismo porque tiene que volver a evaluar el cuerpo de la función para ese 
    nuevo valor.

131. **> CLAVE <** ==>> método de ordenación usado para respetar tildes, mayúsculas y demás:
    Ej.
        [...movies].sort((a, b) => a.title.localeCompare(b.title))   => compara y ordena por title

132. **> CLAVE <** ==>> useMemo : hook que permite memorizar un valor que se recalculará en función de unas dependencias, solo cuando cambien esas dependencias se volverá a ejecutar.
    Con este hook podemos evitar volver a ordenar esta lista si no ha cambiado:
    Ej.
        import { useRef, useState, useMemo } from 'react'
        import { searchMovies } from '../services/movies.js'

        export function useMovies ({ search, sort }) {
            const [movies, setMovies] = useState([])
            const [loading, setLoading] = useState(false)
            const [, setError] = useState(null)
            const previousSearch = useRef(search)

            const getMovies = async () => {
                if (search === previousSearch.current) return

                try {
                    setLoading(true)
                    setError(null)
                    previousSearch.current = search
                    const newMovies = await searchMovies({ search })
                    setMovies(newMovies)
                } catch (e) {
                    setError(e.message)
                } finally {
                    // tanto en el try como en el catch
                    setLoading(false)
                }
            }
            
            const sortedMovies = useMemo( () => {
                sort                                           => si tenemos chequeado el sort lo ordenamos sino no
                    ? [...movies].sort((a, b) => a.title.localeCompare(b.title))    => el localCompare tiene en cuenta las tildes
                    : movies            
            }, [ sort, movies ])      => indicamos que se recalcule o ejecute cuando cambie el check de ordenado o la lista de movies

            // como el search no es una dependencia de nuestro useMemo no se ejecuta aunque cambie el search.

            return { movies: sortedMovies, getMovies, loading }
        }

133. **> CLAVE <** ==>> no usar useMemo en todos los cálculos, a veces vale más la pensa realizar un pequeño cálculo de microsegundos que poner un useMemo para que no se haga.
    En nuestro ejemplo si supieramos que solo hay 10 películas no valdría la pena hacerlo.

134. **> CLAVE <** ==>> Podemos usar el useMemo también para memorizar funciones, y así evitar que se ejecuten cada vez que se renderiza el componente, pasando a ejecutarse solo 
    cuando hemos cambiado las dependencias de nuestro useMemo.
    Ej.
        const getMovies = useMemo( () => { 
            return async () => {
                if (search === previousSearch.current) return

                try {
                    setLoading(true)
                    setError(null)
                    previousSearch.current = search
                    const newMovies = await searchMovies({ search })
                    setMovies(newMovies)
                } catch (e) {
                    setError(e.message)
                } finally {
                    // tanto en el try como en el catch
                    setLoading(false)
                }
            }
        }, [search])

135. IMPORTANTE: Esto no es del todo eficiente, puesto que cada vez que cambiemos el input de la búsqueda nos volverá a generar la función, cuando en realidad lo que queremos es que la
    función se cree una sola vez y luego pasemos a llamarla cuando toque.
    Ej.
        const getMovies = useMemo( () => { 
            return async ({ search }) => {                      => como el search ya lo recibe como parámetro ya no hace falta tenerlo como dependencia
                if (search === previousSearch.current) return

                try {
                    setLoading(true)
                    setError(null)
                    previousSearch.current = search
                    const newMovies = await searchMovies({ search })
                    setMovies(newMovies)
                } catch (e) {
                    setError(e.message)
                } finally {
                    // tanto en el try como en el catch
                    setLoading(false)
                }
            }
        }, [])                                              =>  podemos indicarle que solo se genere la función al crear el componente, la primera vez.        

    **> CLAVE <** ==>> Se ejecutará la función solo cuando se llame, y se generará solo la primera vez que se cree nuestro componente o custom hook.

136. **> CLAVE <** ==>> para identificar problemas de rendimiento lo mejor es usar el Profiler de nuestras devtools de react en el explorador crhome

137. **> CLAVE <** ==>> Como el useMemo queda un poco raro usado para funciones, es una función que se crea para devolver otra función ... existe el hook useCallback que es lo 
    mismo que el useMemo pero pensado para funciones. Por debajo el useCallback utiliza el useMemo de la misma forma que vimos. De hecho es lo mismo pero te ahorras el return, ya que le pasas directamente la función:
    Ej.
        const getMovies = useCallback(
            async ({ search }) => {           => como el search ya lo recibe como parámetro ya no hace falta tenerlo como dependencia
                if (search === previousSearch.current) return

                try {
                    setLoading(true)
                    setError(null)
                    previousSearch.current = search
                    const newMovies = await searchMovies({ search })
                    setMovies(newMovies)
                } catch (e) {
                    setError(e.message)
                } finally {
                    // tanto en el try como en el catch
                    setLoading(false)
                }
        }, []) 

    La sintaxis se simplifica al pasarle directamente la función como primer parámetro y las dependencias como segundo.

138. ¿como implementar que se haga la búsqueda de forma automática al escribir? 
    Ej.
        const handleChange = (event) => {
            const newSearch = event.target.value
            updateSearch(newSearch)
            getMovies({search: newSearch})
        }  

    Simplemente con esto cada vez que escribimos modificando el input lanza una búsqueda y carga las películas.

139. **> CLAVE <** ==>> Pero nos piden que no haga búsquedas de forma continuada, es decir, actualmente si escribimos matrix en el input realizamos 6 búsquedas diferentes:
    una para la m, otra para la ma, otra para la mat, otra para la matr, otra para la matri, y finalmente una para matrix.
    Esto es ineficiente y también genera un problema de RaceCondition, es decir se lanzan varias búsquedas asíncronas pero no sabemos cuál es el orden de finalización de todas ellas, 
    pudiendo ser la última en acabar una de las búsquedas anteriores y mostrando en pantalla un resultado que no es el correspondiente a matrix.

140. **> CLAVE <** ==>> Debounce: es una técnica que nos sirve para resolver el problema anterior, no se va a lanzar la búsqueda de forma inmediata en cada letra tecleada por el usuario
    en el input, sino que se va a esperar un tiempo antes de hacer algo. Podríamos bajarnos librerías que ya lo implementan, incluso un custom hook que lo hace ya hecho.
    Pero vamos a desarrollarlo para aprender como lo haríamos. Recomiendo usar el debounce de la librería Just. Es muy fácil de entender: 
    Se inicia un timeout por ejemplo de 500ms, si se vuelve a llamar se reinicia el timeout a 500ms de nuevo, si no llama nadie cuando el timeout termina ejecuta la función.
    Este sería el funcionamiento del debounce, se puede cancelar.
    Ej.
        npm install just-debounce-it -E
    Si miramos hay varias formas de usar este debounce, se importa y luego se puede llamar sin ejecutarse hasta que venza el timeout establecido, también se puede lanzar ejecutándose la
    primera vez para darle info al usuario y luego ya cuando venza el siguiente timeout. También tenemos las opciones:
        cancel() -> que nos cancela el debounce y ya no se ejecutará la función.
        flush() -> que fuerza a que venza el timeout ejecutando la función de inmediato.

141. Lo implementamos en nuestra App:

    Lo importamos:
    Ej.
        import { useRef, useState, useMemo, useCallback } from 'react'
        import { searchMovies } from '../services/movies.js'
        import debounce from 'just-debounce-it'

    Lo que queremos es aplicar el debounce al getMovies que hay dentro del handleChange, no del que hay dentro del handleSubmit que siempre lo tiene que hacer, ni tampoco al propio handleChange, ya que eso evitaría que se viera por pantalla:

    Creamos el debounce:
    Ej.
        const debounceGetMovies = debounce( search => {
            getMovies(search)
        }, 500)             => 500ms

    Lo llamamos en lugar de llamar a getMovies en el handleChange:
    Ej.
        const handleChange = (event) => {
            const newSearch = event.target.value
            updateSearch(newSearch)
            debounceGetMovies(newSearch)
        }  
    IMPORTANTE: esto no funciona porque tenemos que la función del debounce se genera cada vez que se renderiza el componente, o sea cada vez que lo llamamos porque pasa al cambiar cualquier 
    letra del input. Para evitar esto usamos el useCallback:
    Ej.
        const debounceGetMovies = useCallback( debounce( search => {
                getMovies(search)
            }, 500)
        }, [])                  => podríamos poner getMovies como dependencia, pero ya hemos visto que nuestra getMovies es única y no cambia

    Ahora ya funciona todo.

---------------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------------  


Tienda y Carrito con React + Estado Global con useContext + Manejo de estado con useReducer
https://www.youtube.com/watch?v=B9tDYAZZxcE
---------------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------------  

Carrito de compras:

# Enunciado

Ecommerce

- [x] Muestra una lista de productos que vienen de un JSON
- [x] Añade un filtro por categoría
- [x] Añade un filtro por precio

Haz uso de useContext para evitar pasar props innecesarias.

Carrito:

- [x] Haz que se puedan añadir los productos a un carrito.
- [x] Haz que se puedan eliminar los productos del carrito.
- [x] Haz que se puedan modificar la cantidad de productos del carrito.
- [x] Sincroniza los cambios del carrito con la lista de productos.
- [x] Guarda en un localStorage el carrito para que se recupere al recargar la página. (da puntos)


142. Empezamos nuestro proyecto y App:
    Ej.
        npm create vite@latest
            Preguntará nombre del proyecto: 06-shopping-cart
            React
            TypeScript o JavaScript + SWC
        cd 06-shopping-cart
        npm install
        npm run dev 

143. Quitamos lo que sale por defecto en nuestra App:
    Ej.
        function App () {
            return (
                <h1>Shopping cart</h1>
            )
        }

        export default App

144. Creamos un componente con los iconos que vamos a usar:
    Ej.
        export function AddToCartIcon () {
            return (
                <svg xmlns='http://www.w3.org/2000/svg' width='24' height='24' viewBox='0 0 24 24' strokeWidth='1' stroke='currentColor' fill='none' strokeLinecap='round' strokeLinejoin='round'>
                <path stroke='none' d='M0 0h24v24H0z' fill='none' />
                <path d='M6 19m-2 0a2 2 0 1 0 4 0a2 2 0 1 0 -4 0' />
                <path d='M17 19m-2 0a2 2 0 1 0 4 0a2 2 0 1 0 -4 0' />
                <path d='M17 17h-11v-14h-2' />
                <path d='M6 5l6 .429m7.138 6.573l-.143 1h-13' />
                <path d='M15 6h6m-3 -3v6' />
                </svg>
            )
        }

        export function RemoveFromCartIcon () {
            return (
                <svg xmlns='http://www.w3.org/2000/svg' width='24' height='24' viewBox='0 0 24 24' strokeWidth='1' stroke='currentColor' fill='none' strokeLinecap='round' strokeLinejoin='round'>
                <path stroke='none' d='M0 0h24v24H0z' fill='none' />
                <path d='M6 19m-2 0a2 2 0 1 0 4 0a2 2 0 1 0 -4 0' />
                <path d='M17 19m-2 0a2 2 0 1 0 4 0a2 2 0 1 0 -4 0' />
                <path d='M17 17h-11v-14h-2' />
                <path d='M6 5l8 .571m5.43 4.43l-.429 3h-13' />
                <path d='M17 3l4 4' />
                <path d='M21 3l-4 4' />
                </svg>
            )
        }

        export function ClearCartIcon () {
            return (
                <svg xmlns='http://www.w3.org/2000/svg' width='24' height='24' viewBox='0 0 24 24' strokeWidth='1' stroke='currentColor' fill='none' strokeLinecap='round' strokeLinejoin='round'>
                <path stroke='none' d='M0 0h24v24H0z' fill='none' />
                <path d='M6 19m-2 0a2 2 0 1 0 4 0a2 2 0 1 0 -4 0' />
                <path d='M17 17a2 2 0 1 0 2 2' />
                <path d='M17 17h-11v-11' />
                <path d='M9.239 5.231l10.761 .769l-1 7h-2m-4 0h-7' />
                <path d='M3 3l18 18' />
                </svg>
            )
        }

        export function CartIcon () {
            return (
                <svg xmlns='http://www.w3.org/2000/svg' width='24' height='24' viewBox='0 0 24 24' strokeWidth='1' stroke='currentColor' fill='none' strokeLinecap='round' strokeLinejoin='round'>
                <path stroke='none' d='M0 0h24v24H0z' fill='none' />
                <path d='M6 19m-2 0a2 2 0 1 0 4 0a2 2 0 1 0 -4 0' />
                <path d='M17 19m-2 0a2 2 0 1 0 4 0a2 2 0 1 0 -4 0' />
                <path d='M17 17h-11v-14h-2' />
                <path d='M6 5l14 1l-1 7h-13' />
                </svg>
            )
        }

145. **> CLAVE <** ==>> para ver los campos que tiene nuestro json usamos: jsonformatter.curiousconcept.com
146. Hacemos el componente que al recibir los productos los liste en pantalla:
    Ej. Products.jsx
        import './Products.css'
        import { AddToCartIcon } from './Icons.jsx'

        export function Products ({ products }) {        
            return (
                <main className='products'>                 => como va a ser nuestra parte principal del App, lo ponemos en un main
                    <ul>
                        { products.slice(0, 10).map( product => (       => **> CLAVE <** ==>> usamos slice para mostrar solo 10 productos del 0 al 10
                            <li key={product.id}>
                                <img 
                                    src={product.thumbnail}
                                    alt={product.title}
                                />
                                <div>
                                    <strong>{product.title}</strong> - ${product.price}
                                </div>
                                <div>
                                    <button>
                                        <AddToCartIcon />
                                    </button>
                                </div>
                                
                            </li>
                        ))}
                    </ul>
                </main>
            )
        }

    Modificamos el App con el Products.jsx:
    Ej.  App.jsx
        import {products} from './mocks/products.json'
        import {Products} from './components/Products.jsx'
        
        function App () {
            return (
                <Products products={products} />
            )
        }

        export default App

147. Creamos nuestro products.css con nuestro grid responsive:
    Ej.
        .products {
            width: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .products ul {
            display: grid;
            grid-template-columns: repeat( auto-fit, minmax(200px,1fr) );
            gap: 1rem;
        }

        .products li {
            display: flex;
            flex-direction: column;
            gap: 1rem;
            box-shadow: 0 0 10px 10px rgba(0, 0, 0, .1);
            border-radius: 4px;
            background: #111;
            color: #fff;
            padding: 1rem;
        }

        .products h3 {
            margin: 0;
        }

        .products span {
            font-size: 1rem;
            opacity: .9;
        }

        .products img {
            border-radius: 4px;
            width: 100%;
            aspect-ratio: 16/9;
            display: block;
            object-fit: cover;
            background: #fff;
        }

148. Modificamos en el App para tener los products como un estado, y los inicializamos con el import de products que tenemos ahora:
    Ej.  App.jsx
        import {products as initialProducts} from './mocks/products.json'
        import {Products} from './components/Products.jsx'
        
        function App () {
            const [products] = useState(initialProducts)

            return (
                <Products products={products} />
            )
        }

        export default App

149. Establecemos un estado para filtrar por Categoría y precio:
    Ej.  App.jsx
        import {products as initialProducts} from './mocks/products.json'
        import {Products} from './components/Products.jsx'
        
        function App () {
            const [products] = useState(initialProducts)
            const [filters, setFilters] = useState({                => creamos inicialmente un objeto
                category: 'all',
                minPrice: 0
            })

            return (
                <Products products={products} />
            )
        }

        export default App

150. Ya podemos establecer una función para aplicar nuestros filtros según el estado filters:
    Ej.  App.jsx
        import {products as initialProducts} from './mocks/products.json'
        import {Products} from './components/Products.jsx'
        
        function App () {
            const [products] = useState(initialProducts)
            const [filters, setFilters] = useState({                => creamos inicialmente un objeto
                category: 'all',
                minPrice: 0
            })

            const filterProducts = (products) => {              
                return products.filter(product => {                 => **> CLAVE <** ==>> saber filtrar es básico
                    return ( 
                        product.price >= filters.minPrice &&
                        (
                            filters.category == 'all' ||
                            product.category == filters.category
                        )
                    )
                })   
            }

            const filteredProducts = filterProducts( products )     => conseguimos los productos filtrados

            return (
                <Products products={filteredProducts} />    => los presentamos filtrados
            )
        }

        export default App

151. **> CLAVE <** ==>> los filter en arrays de javascript funcionan así: 

    return products.filter(product => {
        return (condición)
    })

    Es lo mismo que decir:

    “Devuélveme un nuevo array con todos los product donde (condición) sea true”.

    ✅ ¿Cómo funciona .filter() internamente?
        products.filter(product => {
            // Si return true → lo incluye
            // Si return false → lo descarta
        })
    
        Entonces:

        El return interno es lo que decide si cada product pasa el filtro.

        El return externo devuelve todo el array filtrado.

    Podemos evitar el return interno haciendo:
    Ej.
        const filterProducts = (products) => {              
            return products.filter(product => {                 => **> CLAVE <** ==>> es equivalente al anterior con return interno
                product.price >= filters.minPrice &&
                (
                    filters.category == 'all' ||
                    product.category == filters.category
                )
            }) 
        }

152. Ya tenemos funcionando nuestro filtro, aunque nos faltaría la parte visual de selección o establecimiento de los filtros.
    Vamos a crear un nuevo componente Header.jsx:
    Ej. 
        import {Filters} from './Filters.jsx'

        export function Header () {
            return (
                <header>
                    <h1>React Shop</h1>
                    <Filters />
                </header>
            )
        }

    Modificamos nuestro App para que utilice nuestro Header.jsx:
    Ej.  App.jsx
        import {products as initialProducts} from './mocks/products.json'
        import {Products} from './components/Products.jsx'
        
        function App () {
            const [products] = useState(initialProducts)
            const [filters, setFilters] = useState({                => creamos inicialmente un objeto
                category: 'all',
                minPrice: 0
            })

            const filterProducts = (products) => {              
                return products.filter(product => {                 => **> CLAVE <** ==>> saber filtrar es básico
                    return ( 
                        product.price >= filters.minPrice &&
                        (
                            filters.category == 'all' ||
                            product.category == filters.category
                        )
                    )
                })   
            }

            const filteredProducts = filterProducts( products )     => conseguimos los productos filtrados

            return (
                <>                          => IMPORTANTE: tenemos que poner un react.Fragment
                    <Header />
                    <Products products={filteredProducts} />    => los presentamos filtrados
                </>                
            )
        }

        export default App

153. Creamos nuestro componente de Filtros:
    Ej. Filters.jsx
        export function Filters () {
            return (
                <section className='filters'> 
                    <div>
                        <label htmlFor='price'>Price</label>    
                        <input                                  => IMPORTANTE: si utilizamos un rango no veremos el precio seleccionado en el rango. Ver punto 155
                            type='range'
                            id='price'
                            min='0'
                            max='1000'
                        />
                    </div>
                    <div>
                        <label htmlFor=''>Category</label>
                        <select id='category'
                            <option value='all'>Todas</option>
                            <option value='laptops'>Portátiles</option>
                            <option value='smartphones'>Móviles</option>
                        </select>
                    </div>
                </section>
            )
        }

154. Añadimos un Filters.css:

155. Queremos ver el precio seleccionado por el range de nuestro input. Para ello creamos un estado:
    Ej. Filters.jsx
        export function Filters () {
            const [minPrice, setMinPrice] = useState(0)         => añadimos un nuevo estado que tendrá el valor del filtro

            const handleChangeMinPrice = (event) => {
                setMinPrice(event.target.value)                 => cambiamos el estado al nuevo valor segun el evento
            }

            return (
                <section className='filters'> 
                    <div>
                        <label htmlFor='price'>Price</label>    
                        <input                                  => IMPORTANTE: si utilizamos un rango no veremos el precio seleccionado en el rango. Ver punto 155
                            type='range'
                            id='price'
                            min='0'
                            max='1000'
                            onchange={handleChangeMinPrice}     => establecemos el evento change cuando se modique el range
                        />
                        <span>${minPrice}</span>                => visualizamos el valor de nuestro estado
                    </div>
                    <div>
                        <label htmlFor=''>Category</label>
                        <select id='category'
                            <option value='all'>Todas</option>
                            <option value='laptops'>Portátiles</option>
                            <option value='smartphones'>Móviles</option>
                        </select>
                    </div>
                </section>
            )
        }

    **> CLAVE <** ==>> es importante no poner el span con el valor de minPrice delante del range, porque sino al renderizarse hará cosas raras, como saltos. Es mejor renderizarlo 
    después del range.

156. Herramienta para hacer croquis: excalidraw.com

157. **> CLAVE <** ==>> PROP DRILLING: el problema aparece cuando tenemos el setFilters en nuesto componente padre App.jsx, este tiene a sus hijos Header.jsx y Products.jsx. Y a su 
    vez el Header.jsx tiene como hijo al Filters.jsx. Es este Filters.jsx el que necesita leer y poder actualizar el estado filters que está en nuestro App.jsx. Por lo que deberíamos pasar desde
    App.jsx a Header.jsx y a Filters.jsx dicho estado, este camino por el que hay que pasar la prop es el problema conocido como PROP DRILLING( quiere decir que estamos haciendo un
    taladro hacia abajo para pasar la prop ).

    Hacemos los cambios para pasar el prop:
    Ej. App.jsx
        function App () {
            const [products] = useState(initialProducts)
            const [filters, setFilters] = useState({            
                category: 'all',
                minPrice: 0
            })

            const filterProducts = (products) => {              
                return products.filter(product => {             
                    return ( 
                        product.price >= filters.minPrice &&
                        (
                            filters.category == 'all' ||
                            product.category == filters.category
                        )
                    )
                })   
            }

            const filteredProducts = filterProducts( products ) 

            return (
                <>                          
                    <Header changeFilters={setFilters} />           => pasamos el parámetro al Header
                    <Products products={filteredProducts} />    
                </>                
            )
        }

    Ej. Header.jsx
        export function Header ( {changeFilters} ) {
            return (
                <header>
                    <h1>React Shop</h1>
                    <Filters onChange={changeFilters} />
                </header>
            )
        }

    Ej. Filters.jsx
        export function Filters ( {onchange} ) {
            const [minPrice, setMinPrice] = useState(0)         

            const handleChangeMinPrice = (event) => {
                >> ***** AQUI ALGO HUELE MAL ***** <<
                    PROBLEMA: DOS FUENTES DE LA VERDAD      **> CLAVE <** ==>>  es es porque en esta function Filters tenemos un estado local y luego estamos modificando el estado global del app
                                                               mediante la onChange. ESTO ES UNA MALA PRACTICA. Ver resolución en punto  165

                setMinPrice(event.target.value)  
                onChange(prevState => ({                    => cambiamos el estado de nuestros filtros, en concreto el minPrice
                    ...prevState,
                    minPrice: event.target.value
                }))               
            }

            const handleChangeCategory = (event) => {

                onChange(prevState => ({                    => cambiamos el estado de nuestros filtros, en concreto el category
                    ...prevState,
                    category: event.target.value
                }))               
            }

            return (
                <section className='filters'> 
                    <div>
                        <label htmlFor='price'>Price</label>    
                        <input                                  
                            type='range'
                            id='price'
                            min='0'
                            max='1000'
                            onchange={handleChangeMinPrice}     
                        />
                        <span>${minPrice}</span>                
                    </div>
                    <div>
                        <label htmlFor='category'>Category</label>
                        <select 
                            id='category'
                            onChange={handleChangeCategory}>
                            <option value='all'>Todas</option>
                            <option value='laptops'>Portátiles</option>
                            <option value='smartphones'>Móviles</option>
                        </select>
                    </div>
                </section>
            )
        }

        **> CLAVE <** ==>> Estamos pasando un useState desde un componente padre a un componente hijo y en el componente hijo lo usamos sin saber que es un 
        estado de react. No sabemos que onChange es un estado de react. Esto no se debe hacer así.            

158. **> CLAVE <** ==>> No usar useMemo o useCallback por defecto porque el coste puede ser mayor que el beneficio, hacerlo solo cuando tengamos un problema de rendimiento.

159. **> CLAVE <** ==>> Nuevo hook useId: sirve para generar un ID único que además usa server side rendering. Se basan en la posición del hook dentro de react en nuestra Aplicación,
    y como los hooks siempre tienen que mantener el mismo orden, pues será un identificador único incluso en el lado de servidor, es un identificador Universal, será el mismo en cliente
    y en servidor. No se puede usar para iteraciones, es decir como key.map(...), eso requiere un identificador único dentro del elemento a iterar, y esto es un identificador basado en
    el orden de llamada. Es ideal para Ids en código de renderizado html.

    Para evitar errores en nuestro código anterior hacemos uso de este hook:
    Ej. Filters.jsx
        export function Filters ( {onchange} ) {
            const [minPrice, setMinPrice] = useState(0)   
            const minPriceFilterId = useId()                => IMPORTANTE: creamos los Identificadores únicos gracias al hook
            const categoryFilterId = useId()      

            const handleChangeMinPrice = (event) => {
                setMinPrice(event.target.value)  
                onChange(prevState => ({                    
                    ...prevState,
                    minPrice: event.target.value
                }))               
            }

            const handleChangeCategory = (event) => {
                onChange(prevState => ({                    
                    ...prevState,
                    category: event.target.value
                }))               
            }

            return (
                <section className='filters'> 
                    <div>
                        <label htmlFor={minPriceFilterId}>Price</label>             => usamos el Id creado con el hook useId()
                        <input                                  
                            type='range'
                            id={minPriceFilterId}                                   => usamos el Id creado con el hook useId()
                            min='0'
                            max='1000'
                            onchange={handleChangeMinPrice}     
                        />
                        <span>${minPrice}</span>                
                    </div>
                    <div>
                        <label htmlFor={categoryFilterId}>Category</label>          => usamos el Id creado con el hook useId()
                        <select 
                            id={categoryFilterId}                                   => usamos el Id creado con el hook useId()
                            onChange={handleChangeCategory}>
                            <option value='all'>Todas</option>
                            <option value='laptops'>Portátiles</option>
                            <option value='smartphones'>Móviles</option>
                        </select>
                    </div>
                </section>
            )
        }

160. Vamos a crear un custom hook para todo el tema de filteredProducts:
    Ej. useFilters.js
        function useFilters () {
            const [filters, setFilters] = useState({            
                category: 'all',
                minPrice: 0
            })

            const filterProducts = (products) => {              
                return products.filter(product => {             
                    return ( 
                        product.price >= filters.minPrice &&
                        (
                            filters.category == 'all' ||
                            product.category == filters.category
                        )
                    )
                })   
            }
            return { filterProducts, setFilters }
        }
    Modificamos nuestra App para usar el custom hook
    Ej. App.jsx
        function App () {
            const [products] = useState(initialProducts)
            const { filterProducts, setFilters } = useFilters()

            const filteredProducts = filterProducts( products ) 

            return (
                <>                          
                    <Header changeFilters={setFilters} />           => pasamos el parámetro al Header
                    <Products products={filteredProducts} />    
                </>                
            )
        }

161. Creamos un componente footer que además incorpora los filtros que tenemos activados que solo aparecerá si estamos en desarrollo:
    Como necesitaremos los filters los sacamos de nuestro useFilters:
    Ej. useFilters.js
        function useFilters () {
            const [filters, setFilters] = useState({            
                category: 'all',
                minPrice: 0
            })

            const filterProducts = (products) => {              
                return products.filter(product => {             
                    return ( 
                        product.price >= filters.minPrice &&
                        (
                            filters.category == 'all' ||
                            product.category == filters.category
                        )
                    )
                })   
            }
            return { filters, filterProducts, setFilters }

    Ej. Footer.jsx
        import './Footer.css'

        export function Footer ({filters}) {
            return (
                <footer className='footer'>
                    {
                        JSON.stringify(filters, null, 2)            =>  IMPORTANTE: esto puede ser util para montarnos como un debuger de estados en nuestro componente
                    }
                    {
                        <h4>Prueba técnica de React ⚛️ － <span>@midudev</span></h4>
                        <h5>Shopping Cart con useContext & useReducer</h5>
                    }
                </footer>
            )
        }

    Para saber si estamos en desarrollo lo hacemos en un config.js:
    Ej. config.js
        export const IS_DEVELOPMENT = process.env.NODE_ENV != 'production'      => NODE_ENV cambia de forma automática con production cuando lo empaquetamos para productivo

    Lo llamamos en el App.jsx controlando si es en desarrollo:
    Ej. App.jsx
        function App () {
            const [products] = useState(initialProducts)
            const { filterProducts, setFilters } = useFilters()

            const filteredProducts = filterProducts( products ) 

            return (
                <>                          
                    <Header changeFilters={setFilters} />       
                    <Products products={filteredProducts} />    
                    {IS_DEVELOPMENT && <Footer filters={filters}/>}
                </>                
            )
        }

162. Vemos entonces que parece que el componente App tiene que pasar todo el tema de los filters al resto de componentes, sería mucho más interesante que solo los componentes que tengan 
    que acceder a los filtros puedan obtenerlos sin depender del componente App.

163. **> CLAVE <** ==>> Nuevo Hook useContext: el contexto es algo separado de nuestro árbol de componentes y que pueden leer de forma separada. ¿cómo podemos acceder a esa información de contexto
    desde nuestros componentes y app ? Envolviendolos con un Provider. De tal forma que todo lo que envolvemos con nuestro Provider tendrá acceso a ese contexto.

    Ej. /context/filter.jsx

    1. CREAMOS EL CONTEXTO:
    import { createContext } from 'react'

    // Este es el que tenemos que consumir
    export const FiltersContext = createContext()

    2. CREAMOS EL PROVIDER PARA ESE CONTEXTO:
    // Este es el que nos provee de acceso al contexto
    export function FiltersProvider ({ children }) {
        return (
            <FiltersContext.Provider value={{
                filters,
                setFilters
            }}
            >
                {children}
            </FiltersContext.Provider>
        )
    }

    3. ENVOLVER NUESTRA APP con NUESTRO PROVIDER:
    // simplemente envolvemos con nuestro provider en este caso toda la App:
    Ej. main.jsx
        import ReactDOM from 'react-dom/client'
        import App from './App'
        import {FiltersProvider} from './context/filters.jsx'
        import './index.css'

        ReactDOM.createRoot(document.getElementById('root')).render(
            <FiltersProvider>
                <App />
            </FiltersProvider>
        )

    4. CONSUMIMOS EL CONTEXTO:
        Ej. custom hook useFilters.jsx
            import { useContext } from 'react'                                  => indicamos el uso del hook
            import { FiltersContext } from '../context/filters.jsx'             => cargamos el fichero de contexto en nuestro custom hook

            export function useFilters () {
                const { filters, setFilters } = useContext(FiltersContext)      => cargamos los estados y funciones desde el contexto 

                const filterProducts = (products) => {
                    return products.filter(product => {
                    return (
                        product.price >= filters.minPrice &&
                        (
                        filters.category === 'all' ||
                        product.category === filters.category
                        )
                    )
                    })
                }

                return { filters, filterProducts, setFilters }
            }

    En este punto nuestro contexto ya lo estamos consumiendo, pero hemos puesto un contexto estático, por lo que no cambiará aunque modifiquemos nuestro estado filters.
    Pero podemos tener contextos con datos estáticos y no es ningún error.
    Vamos a arreglarlo para que sea dinámico:

        Ej. context/filters.jsx
        import { createContext, useState } from 'react'     => incorporamos el useState

        // Este es el que tenemos que consumir
        export const FiltersContext = createContext()

        // Este es el que nos provee de acceso al contexto
        export function FiltersProvider ({ children }) {
            const [filters, setFilters] = useState({               => creamos nuestro estado dinámico para filters
                category: 'all',
                minPrice: 250
            })

            return (
                <FiltersContext.Provider value={{
                    filters,                            => nuestro value devuelve el contenido de nuestro estado y su función de modificación
                    setFilters
                }}
                >
                {children}
                </FiltersContext.Provider>
            )
        }

164. Eliminamos el PROP DRILLING que tenemos antes de crear el contexto:
    Ej. Header.jsx
        import { Filters } from './Filters.jsx'

        export function Header () {
            return (
                <header>
                    <h1>React Shop 🛒</h1>
                    <Filters />
                </header>
            )
        }

    Ej. useFilters.jsx
        import { useContext } from 'react'
        import { FiltersContext } from '../context/filters.jsx'     => cargamos el contexto

        export function useFilters () {
            const { filters, setFilters } = useContext(FiltersContext)      => usamos el contexto

            const filterProducts = (products) => {
                return products.filter(product => {
                    return (
                        product.price >= filters.minPrice &&
                        (
                            filters.category === 'all' ||
                            product.category === filters.category
                        )
                    )
                })
            }

            return { filters, filterProducts, setFilters }
        }

    Ej. Footer.jsx
        import './Footer.css'
        import { useContext } from 'react'
        import { FiltersContext } from '../context/filters.jsx'     => cargamos el contexto

        export function Footer () {
            const { filters } = useContext(FiltersContext)      => usamos el contexto

            return (
                <footer className='footer'>
                    {
                        JSON.stringify(filters, null, 2)            =>  IMPORTANTE: esto puede ser util para montarnos como un debuger de estados en nuestro componente
                    }
                    {
                        <h4>Prueba técnica de React ⚛️ － <span>@midudev</span></h4>
                        <h5>Shopping Cart con useContext & useReducer</h5>
                    }
                </footer>
            )
        }

    Ej. App.jsx
        function App () {
            const [products] = useState(initialProducts)
            const { filterProducts } = useFilters()

            const filteredProducts = filterProducts( products ) 

            return (
                <>                          
                    <Header />                                          => quitamos el paso de prop
                    <Products products={filteredProducts} />    
                    {IS_DEVELOPMENT && <Footer/>}                       => quitamos el paso de prop
                </>                
            )
        }        

165. Nos debemos fiar de un solo estado, debe ser el global, por lo que eliminamos el estado local en Filters.jsx:
    Ej. Filters.jsx
        import { useId } from 'react'
        import { useFilters } from '../hooks/useFilters.js'
        import './Filters.css'

        export function Filters () {
            const { filters, setFilters } = useFilters()        => traemos filters como estado global a nuestro componente desde nuestro custom hook

            const minPriceFilterId = useId()
            const categoryFilterId = useId()

            const handleChangeMinPrice = (event) => {
                setFilters(prevState => ({
                    ...prevState,
                    minPrice: event.target.value
                }))
            }

            const handleChangeCategory = (event) => {
                setFilters(prevState => ({
                ...prevState,
                category: event.target.value
                }))
            }

            return (
                <section className='filters'>

                <div>
                    <label htmlFor={minPriceFilterId}>Precio a partir de:</label>
                    <input
                    type='range'
                    id={minPriceFilterId}
                    min='0'
                    max='1000'
                    onChange={handleChangeMinPrice}
                    value={filters.minPrice}                    => usamos el filters global
                    />
                    <span>${filters.minPrice}</span>            => usamos el filters global
                </div>

                <div>
                    <label htmlFor={categoryFilterId}>Categoría</label>
                    <select id={categoryFilterId} onChange={handleChangeCategory}>
                    <option value='all'>Todas</option>
                    <option value='laptops'>Portátiles</option>
                    <option value='smartphones'>Celulares</option>
                    </select>
                </div>

                </section>

            )
        }

166. IMPORTANTE: ¿si ponemos en varios sitios nuestro Provider se cargará varias veces? NO, como es javascript el import es un singleton, solo se carga una vez.

167. Hacemos la parte del CARRITO del enunciado:
    Creamos el componente Cart.jsx:
    Ej. Cart.jsx
        import './Cart.css'
        import { useId } from 'react'
        import { CartIcon, ClearCartIcon } from './Icons.jsx'

        export function Cart () {
            const cartCheckboxId = useId()
        
            return (
                <>
                    <label className='cart-button' htmlFor={cartCheckboxId}>
                        <CartIcon />
                    </label>
                    <input id={cartCheckboxId} type='checkbox' hidden />
                    <aside className='cart'>
                        <ul>
                            {cart.map(product => (
                                <CartItem
                                key={product.id}
                                addToCart={() => addToCart(product)}
                                {...product}
                                />
                            ))}
                        </ul>

                        <button onClick={clearCart}>
                            <ClearCartIcon />
                        </button>
                    </aside>
                </>
            )
        }

168. Le damos estilos al carrito:
    Ej.
        .cart {
            background: #000;
            display: none;          => por defecto no se muestra
            padding: 32px;
            position: fixed;
            right: 0px;
            top: 0px;
            width: 200px;
        }

        ...

        .cart-button ~ input:checked ~ .cart {      => lo que hace esto es que cuando el botón esté checked se vea el carrito
            height: 100%;
            display: block;
        }

        **> CLAVE <** ==>> CSS Avanzado: selector HERMANO (~); este css visto antes: “Selecciona el .cart que esté después de un <input> que está checked, y ese <input> a su vez debe estar después de .cart-button”:
        Ej.
            <label className='cart-button' htmlFor={cartCheckboxId}>
                <CartIcon />
            </label>
            <input id={cartCheckboxId} type='checkbox' hidden />
            <aside className='cart'>                                    => selecciona esto y lo hace visible con todo el alto
                ...
            </aside>

169. Creamos el contexto y el provider con su children para el carrito:
    Ej. cart.jsx
        import { createContext, useState } from 'react'
        
        export const CartContext = createContext()
        export function CartProvider ({ children }) {
            const { cart, setCart } = useState([])

            const addCart = product => {
                // ver si el producto está ya en el carrito
                const productInCartIndex = cart.findIndex(item => item.id == product.id)  => buscamos el índice del item que tenga el mismo id que nuestro producto

                if(productInCartIndex >= 0) { => existe el producto                
                    const newCart = structuredClone(cart)       => crea un clon profundo de nuestro carrito en newCart. Puede que no sea la forma más eficiente para arrays grandes
                    newCart[productInCartIndex].quantity += 1   => aumentamos la cantidad de ese producto en nuestra copia del carrito
                    setCart(newCart)                            => actualizamos nuestro carrito con la copia
                }

                // el spread operator no es aconsejable porque no hace una copia profunda, solo superficial, y eso nos podría dar problemas.
                // otras alternativas más rápidas sería con map o con slice, esta última sería la mejor.

                // El producto no está en el carrito
                setCart(prevState => ([
                    ...prevState,
                    {
                        ...product,
                        quantity: 1
                    }
                ]))
            }

            const clearCart = () => {
                setCart([])
            }

            return (
                <CartContext.Provider value={{
                    cart,
                    addToCart,
                    clearCart
                }}
                >
                    {children}
                </CartContext.Provider>
            )
        }

170. Hacemos un custom hook para nuestro carrito:
    Ej. useCart.jsx
        import { useContext } from 'react'
        import { CartContext } from '../context/cart.jsx'

        export const useCart = () => {
            const context = useContext(CartContext)

            if (context === undefined) {                                        => control para saber si tenemos el dato de contexto, puede ser que no tengamos contexto en esta ubicación en la que estamos intentando usar nuestro contexto.
                throw new Error('useCart must be used within a CartProvider')
            }

            return context
        }

171. En este caso no necesitamos el contexto en nuestra App, por lo que ponemos el provider en el mismo App dejándo el componente App.jsx fuera del envoltorio del Provider.
    Ej. App.jsx
        import { Cart } from './components/Cart.jsx'
        import { CartProvider } from './context/cart.jsx'

        function App () {
            const { filterProducts } = useFilters()

            const filteredProducts = filterProducts(initialProducts)

            return (
                <CartProvider>
                    <Header />
                    <Cart />
                    <Products products={filteredProducts} />
                    {IS_DEVELOPMENT && <Footer />}
                </CartProvider>
            )
        }

        export default App

172. En nuestro Footer añadimos el carrito:
    Ej.Footer.jsx
        import './Footer.css'
        import {useCart} from '../hooks/useCart.js'
        import {useFilters} from '../hooks/useFilters.js'

        export function Footer () {
            const { filters } = useFilters()
            const { cart } = useCart()

            return (
                <footer className='footer'>
                    {
                        JSON.stringify(filters, null, 2)            
                    }
                                        {
                        JSON.stringify(cart, null, 2)            
                    }
                    {
                        <h4>Prueba técnica de React ⚛️ － <span>@midudev</span></h4>
                        <h5>Shopping Cart con useContext & useReducer</h5>
                    }
                </footer>
            )
        }

173. Modificamos nuestro Products.jsx con el click del añadir al carrito y un chequeo de si un producto está en el carrito:
    Ej. Products.jsx
        import './Products.css'
        import { AddToCartIcon } from './Icons.jsx'
        import { useCart } from './hooks/useCart.js'

        export function Products ({ products }) {  
            const { addToCart, RemoveFromCart, cart }=useCart()          => añadimos lo que necesitamos del custom hook

            const checkProductInCart = product => {
                return cart.some(item => item.id == product.id)
            }

            return (
                <main className='products'>                 
                    <ul>
                        { products.slice(0, 10).map( product => {
                            const isProductInCart = checkProductInCart(product)    

                            return (
                                <li key={product.id}>
                                    <img 
                                        src={product.thumbnail}
                                        alt={product.title}
                                    />
                                    <div>
                                        <strong>{product.title}</strong> - ${product.price}
                                    </div>
                                    <div>
                                        <button onclick={() => {
                                            isProductInCart 
                                                ? RemoveFromCart(product)       => añadimos la opción de eliminar del carrito
                                                : addToCart(product)
                                        }}
                                        >
                                            {
                                                isProductInCart
                                                    ? <RemoveFromCartIcon />
                                                    : <AddToCartIcon />
                                            }
                                        </button>
                                    </div>                
                                </li>
                            )}
                        )}
                    </ul>
                </main>
            )
        }


174. En nuestro contexto / provider añadimos la función RemoveFromCart:
    Ej. cart.jsx
        import { createContext, useState } from 'react'
        
        export const CartContext = createContext()
        export function CartProvider ({ children }) {
            const { cart, setCart } = useState([])

            const addCart = product => {
                // ver si el producto está ya en el carrito
                const productInCartIndex = cart.findIndex(item => item.id == product.id)  

                if(productInCartIndex >= 0) { => existe el producto                
                    const newCart = structuredClone(cart)       
                    newCart[productInCartIndex].quantity += 1   
                    setCart(newCart)                            
                }

                // El producto no está en el carrito
                setCart(prevState => ([
                    ...prevState,
                    {
                        ...product,
                        quantity: 1
                    }
                ]))
            }

            const RemoveFromCart = product => {                                             => nueva funcion para eliminar un producto del carro
                setCart(prevState => prevState.filter(item => item.id != product.id))       => **> CLAVE <** ==>>  el uso de prevState es algo que nos permite las funciones en javascript, ya que viene el estado previo y podemos acceder a el
            }                                                                                       No lo hacemos con el estado directamente porque podríamos tener problemas de RaceCondition y no tener el último valor actualizado en el estado.

            const clearCart = () => {
                setCart([])
            }

            return (
                <CartContext.Provider value={{
                    cart,
                    addToCart,
                    RemoveFromCart,                             => añadimos la nueva funcion para que la devuelva el provider
                    clearCart
                }}
                >
                    {children}
                </CartContext.Provider>
            )
        }


173. Modificamos nuestro Products.jsx con el click del añadir al carrito y un chequeo de si un producto está en el carrito:
    Ej. Products.jsx
        import './Products.css'
        import { AddToCartIcon } from './Icons.jsx'
        import { useCart } from './hooks/useCart.js'

        export function Products ({ products }) {  
            const {addToCart}=useCart()

            const checkProductInCart = product => {
                return cart.some(item => item.id == product.id)
            }

                        return (
                <main className='products'>                 
                    <ul>
                        { products.slice(0, 10).map( product => {
                            const isProductInCart = checkProductInCart(product)    => chequeamos

                            return (
                                <li key={product.id}>
                                    <img 
                                        src={product.thumbnail}
                                        alt={product.title}
                                    />
                                    <div>
                                        <strong>{product.title}</strong> - ${product.price}
                                    </div>
                                    <div>
                                        <button onclick={() => {
                                            isProductInCart 
                                                ? RemoveFromCart(product)       
                                                : addToCart(product)
                                        }}
                                        >
                                            {
                                                isProductInCart                     => condicionamos las opciones
                                                    ? <RemoveFromCartIcon />
                                                    : <AddToCartIcon />
                                            }
                                        </button>
                                    </div>                
                                </li>
                            )}
                        )}
                    </ul>
                </main>
            )
        }

174. Vamos a vaciar el carrito:
    Ej. Cart.jsx    
        import { useId } from 'react'
        import { CartIcon, ClearCartIcon } from './Icons.jsx'
        import { useCart } from '../hooks/useCart.js'

        function CartItem ({ thumbnail, price, title, quantity, addToCart }) {
            return (
                <li>
                    <img
                        src={thumbnail}
                        alt={title}
                    />
                    <div>
                        <strong>{title}</strong> - ${price}
                    </div>

                    <footer>
                        <small>
                            Qty: {quantity}
                        </small>
                        <button onClick={addToCart}>+</button>      => llamamos a la funcion que añade el carrito
                    </footer>
                </li>
            )
        }

        export function Cart () {
            const cartCheckboxId = useId()
            const { cart, clearCart, addToCart } = useCart()

            return (
                <>
                    <label className='cart-button' htmlFor={cartCheckboxId}>
                        <CartIcon />
                    </label>
                    <input id={cartCheckboxId} type='checkbox' hidden />

                    <aside className='cart'>
                        <ul>
                            {cart.map(product => (
                                <CartItem
                                    key={product.id}
                                    addToCart={() => addToCart(product)}    => pasamos ya la función con el código, de esa forma el componente CartItem no requiere conocer la función
                                    {...product}                                este addToCart está dentro del hook useCart. 
                                />
                            ))}
                        </ul>

                        <button onClick={clearCart}>
                            <ClearCartIcon />
                        </button>
                    </aside>
                </>
            )
        }

175. **> CLAVE <** ==>> es recomendable usar un custom hook para importar el contexto simplemente aunque no lo use, por:

    Ventajas de usar un custom hook como useCart()
        1. Encapsulación y validación
            Tu useCart incluye una verificación:

            if (context === undefined) {
                throw new Error('useCart must be used within a CartProvider')
            }
            
            Esto evita errores silenciosos y te da una advertencia clara si alguien usa el hook fuera del CartProvider, algo que no tendrías si usas useContext(CartContext) directamente.

        2. Abstracción limpia
            Al usar useCart():

            const { cart, clearCart, addToCart } = useCart()
                → ocultas los detalles de cómo funciona el contexto internamente. Si más adelante quieres cambiar la implementación (por ejemplo, cambiar de Context a Zustand, Redux, etc.), solo tienes que actualizar el custom hook, no todos los componentes que lo consumen.

        3. Consistencia en toda la app
            Establece un patrón claro y uniforme. Si todos usan useCart() en lugar de useContext(CartContext), es más fácil:
                Refactorizar
                Entender el código
                Prevenir errores

        4. Escalabilidad
            Puedes enriquecer useCart() con lógica adicional, por ejemplo:

                export const useCart = () => {
                    const context = useContext(CartContext)
                    if (!context) throw new Error('useCart must be used within CartProvider')
                    const { cart, addToCart, clearCart } = context
                    const totalItems = cart.reduce((sum, item) => sum + item.quantity, 0)
                    return { cart, addToCart, clearCart, totalItems }
                }

            Ahora todos los componentes que usen useCart() tienen acceso a totalItems sin duplicar la lógica.

176. Función .bind() nos permite asignar el valor this que tu quieras y devolver la misma función pero con el this especificado, era útil en los componentes de clase, pero no es una buena práctica usarlo en react:
    Ej.
        addToCart={() => addToCart( product )}    mejor que   addToCart={addToCart.bind( this, product )}

177. **> CLAVE <** ==>> el useReduce() es un hook que nos permite manejar el estado de una manera escalable porque se basa en que recibe el estado actual y la acción que tiene que hacer y a partir de ellos devuelve el nuevo 
    estado. El estado inicial puede ser cualquier cosa, un objeto, un array, un valor, ... IMPORTANTE: no se llama Reduce porque reduce el estado, sería que lo transforma, como en cocina es una reducción a fuego lento.
    Ej.
        // necesitamos un estado inicial
        const initialState = []
        // y un Reducer
        const reducer = (state, action) => {
            const { type: actionType, payload: actionPayload } = action
            switch (action.type) {
                case 'ADD_TO_CART': {
                    const productInCartIndex = state.findIndex(item => item.id === action.payload.id)

                    if(productInCartIndex >= 0) {
                        const newState = structuredClone(state)
                        newState[productInCartIndex].quantity += 1
                        return newState                                  => devuelve directamente el nuevo estado
                    }

                    // producto no está en el carrito
                    return [
                        ...state,
                        {
                            ...actionPayload,   // product
                            quantity: 1
                        }
                    ]
                }

                case 'REMOVE_FROM_CART': {
                    const { id } = actionPayload
                    return state.filter(item => item.id != id)
                }

                case 'CLEAR_CART': {
                    return initialState
                }
            }
            return state
        }

    Con esto ya tenemos nuestro Reducer, lo guardamos en el directorio reducers como cart.js, ahora lo llamamos desde nuestro Provider y lo dejamos simplificado:
    Ej. context/cart.jsx 
        import { useReducer, createContext } from 'react'
        import { cartReducer, cartInitialState } from '../reducers/cart.js'     => importamos el fichero con nuestro reduce

        export const CartContext = createContext()

        function useCartReducer () {                                                => creamos un funcion para usar el reduce
            const [state, dispatch] = useReducer(cartReducer, cartInitialState)     => recibimos de llamada al hook de react el state y un dispatch, le mandamos el cartReducer que exportamos en nuestro reducer y el estado inicial

            const addToCart = product => dispatch({     => usamos al funcion dispatch para llamar a nuestro reduce
                type: 'ADD_TO_CART',
                payload: product
            })

            const removeFromCart = product => dispatch({    => usamos al funcion dispatch para llamar a nuestro reduce
                type: 'REMOVE_FROM_CART',
                payload: product
            })

            const clearCart = () => dispatch({ type: 'CLEAR_CART' })    => usamos al funcion dispatch para llamar a nuestro reduce

            return { state, addToCart, removeFromCart, clearCart }
        }

    Vale la pena porque permite separar toda la lógica de actualización de tu estado del resto en una función. Que la podemos llevar a donde queramos. Es fácil de testear:
    Solo tenemos que llamar a la función reducer para testearlo, mientras que sin ella las funciones están dentro de nuestro componente y para testearlas tendremos que renderizar
    nuestro componente, ya que están en el cuerpo del mismo provider.
    Ejemplo de test:
        expect(
            reducer([], {type: 'ADD_TO_CART', payload: {id:1}})
        ).toEqual([{id:1, quantity: 1}])
    
    Cuando usarlo: si tenemos muchos useState uno detrás de otro. También podríamos sacarlo en un custom hook.

178. Podemos mejorar nuestro reducer añadiendo un enumerado de las acciones:
    Ej.
        export const CART_ACTION_TYPES = {
            ADD_TO_CART: 'ADD_TO_CART',
            REMOVE_FROM_CART: 'REMOVE_FROM_CART',
            CLEAR_CART: 'CLEAR_CART'
        }

        // necesitamos un estado inicial
        const initialState = []
        // y un Reducer
        const reducer = (state, action) => {
            const { type: actionType, payload: actionPayload } = action
            switch (action.type) {
                case CART_ACTION_TYPES.ADD_TO_CART: {
                    const productInCartIndex = state.findIndex(item => item.id === action.payload.id)

                    if(productInCartIndex >= 0) {
                        const newState = structuredClone(state)
                        newState[productInCartIndex].quantity += 1
                        return newState                                  => devuelve directamente el nuevo estado
                    }

                    // producto no está en el carrito
                    return [
                        ...state,
                        {
                            ...actionPayload,   // product
                            quantity: 1
                        }
                    ]
                }

                case CART_ACTION_TYPES.REMOVE_FROM_CART: {
                    const { id } = actionPayload
                    return state.filter(item => item.id != id)
                }

                case CART_ACTION_TYPES.CLEAR_CART: {
                    return initialState
                }
            }
            return state
        }

    También adaptaríamos con el enumerado las llamadas de nuestro dispatch.

179. IMPORTANTE: otras formas de hacer el cambio del elemento en nuestro estado:
    Ej. 1. la que tenemos con structuredClone
        if(productInCartIndex >= 0) {
            const newState = structuredClone(state)             => esta es la más legible y fácil de hacer
            newState[productInCartIndex].quantity += 1
            return newState                                  
        }
    Ej. 2. Con slice (seguramente la mas eficiente)
        if(productInCartIndex >= 0) {
            const newState = [
                ...state.slice(0, productInCartIndex),          => coje los elementos desde el 0 hasta el indice que sabemos
                { ...state[productInCartIndex], quantity: state[productInCartIndex].quantity + 1 },     => modifica la cantidad del elemento 
                ...state.slice(productInCartIndex + 1)          => coje el resto de elementos
            ]
            return newState
        }
    Ej. 3. Con map:
        if(productInCartIndex >= 0) {
            const newState = state.map(item => {
                if (item.id === id) {
                    return {
                        ...item,
                        quantity: item.quantity + 1
                    }
                }
            })
            return newState
        }

180. Por útimo añadimos el uso de localStorage para guardar y recuperar nuestro carrito:
    Ej.
        // Leer
        export const cartInitialState = JSON.parse(window.localStorage.getItem('cart')) || []

        // creamos la función para guardar en el localStorage
        export const updateLocalStorage = state => {
            window.localStorage.setItem('cart', JSON.stringify(state))
        }

        // hacemos las correspondientes llamadas en todo los sitios susceptibles de cambio:
        - En cada acción del reducer justo antes de devolver el state nuevo:
            updateLocalStorage(newState)

---------------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------------  


Aprende a crear React Router desde cero y publica el paquete
https://www.youtube.com/watch?v=K2NcGYajvY4
---------------------------------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------------------------------- 

181. La práctica consiste en Crear un React Router desde cero:
    # Crea un React Router desde cero

    - [x] Instalar el linter
            npm install eslint --save-dev
            npx eslint --init               => si quieres inicializarlo
            npm install standard -D         => si quieres añadir directamente unas reglas
    - [x] Crear una forma de hacer MPAs (Multiple Page Application)
    - [x] Crea una forma de hacer SPAs (Single Page Applications)
    - [x] Poder navegar entre páginas con el botón de atrás
    - [x] Crear componente Link para hacerlo declarativo
    - [x] Crear componente Router para hacerlo más declarativo
    - [x] Soportar ruta por defecto (404)
    - [x] Soportar rutas con parámetros
    - [x] Componente <Route /> para hacerlo declarativo
    - [x] Lazy Loading de las rutas
    - [x] Hacer un i18n con las rutas
    - [x] Testing
    - [x] Publicar el paquete en NPM


182. Utilizamos un link para establecer unos estilos tipo bootstrap pero más pequeño:
    Ej.
        <link rel="stylesheet" href="https://cdn.simplecss.org/simple.min.css">

183. Inicialmente montamos 2 páginas que nos permiten navegar entre ellas, saltando de una a otra, y renderizando de nuevo toda la página. Esto es lo que se llama:
    MPAs o Multiple Page Application.

184. Para crear una SPA vamos primero a crear una funcion de navegacion.
    Ej.
        const NAVIGATION_EVENT = 'pushstate'

        function navigate(href) {
            window.history.pushState({}, '', href)   => cambia la url de la barra de direcciones pero sin navegar a la página
            // crear un evento personalizado para avisar de que hemos cambiado la url
            const navigationEvent = new Event(NAVIGATION_EVENT)
            // lanzamos el evento para quien lo quiera escuchar
            window.dispatchEvent(navigationEvent)
        }

185. **> CLAVE <** ==>> Añadimos un useEffect para escuchar nuestro evento:
    Ej.
        useEffect(() => {
            const onLocationChange = () => {                => importante guardar en const la funcion a escuchar y luego eliminar
                setCurrentPath(window.location.pathname)
            } 

            // Escuchamos el evento de navegación
            window.addEventListener(NAVIGATION_EVENT, onLocationChange)
            // Escuchamos el evento del navegador cuando damos al boton de ir para atrás
            window.addEventListener('popstate', onLocationChange)

            return () => {
                // Limpiamos el evento al desmontar el componente
                window.removeEventListener(NAVIGATION_EVENT, onLocationChange)
                window.removeEventListener('popstate', onLocationChange)
            }
        }, [])

186. IMPORTANTE: <button onClick={navigate('/about')}>Go to About Page</button> esto no funciona porque está ejecutando la funcion antes de que hagamos click, debemos 
    hacer:  <button onClick={() => navigate('/about')}>Go to About Page</button>

187. **> CLAVE <** ==>> Problema: si vamos hacia atrás en el navegador no cambia el contenido de la página a pesar de que cambia la url. Escuchamos el evento que genera el navegador al dar al 
    botón de ir hacia atrás: Ej. window.addEventListener('popstate', onLocationChange)

188. **> CLAVE <** ==>> Si ponemos un Button para navegar por una página web este no es detectado por los rastreadores de navegabilidad y por lo tanto es un problema de accesibilidad para 
    personas discapacitadas que no podrán verlo y en consecuencia usarlo. Para ello es mejor usar anchor (ancla). Además de que el botón si le das con el raton y boton derecho no presenta las opciones
    del ancla de abrir en otra pestaña o ... Por lo que NO HAY QUE USAR UN BUTTON PARA HACER NAVEGACION.
    Ej. 
        <a href="/about">Ir a la página About</a>
    En React (SPA)
    En React, usamos a solo para enlaces fuera de la app. Para navegación dentro de la app (SPA), se recomienda usar <Link> de React Router o tu propio componente, para evitar recargar toda la página:

        import { Link } from 'react-router-dom'

        <Link to="/about">About Page</Link>
    Esto simula la navegación sin recargar el navegador (client-side routing).

189. Creamos un Link.jsx donde su función principal tiene en cuenta la navegación con un click:
    Ej.
        export function Link({ target, to, ...props }) {          => **> CLAVE <** ==>> usa el operador rest para recibir el resto de propiedades que pongamos en nuestras llamadas, solo extrae de forma directa el target y el to
            const handleClick = (event) => {
                // Prevenir el comportamiento por defecto del enlace => si no hacemos esto nos recargará la página de nuevo y no sería SPA
                event.preventDefault()          
                navigate(to)
            }

            return <a onClick={handleClick} href={to} target={target} {...props} />     **> CLAVE <** ==>> inyecta todas las propiedades que nos llegan al elemento <a>    
        }

    PROBLEMA: solo tenemos en cuenta el Click del ratón, no hace caso de las combinaciones de teclas que combinadas con el click deben abrir nueva ventana o pestaña
    para esa navegación. Ejemplo MAYUSCULAS + Click: abre en nueva ventana. CONTROL + Click: abre en nueva pestaña

190. **> CLAVE <** ==>> nuestro ancla (anchor) pinta el título porque en realidad al pasarle las ...props le estamos pasando el children de la forma: children={props.children}
    Por eso tiene acceso a los datos.

191. Creamos nuestro Router como lo tenemos en react:
    Definimos las rutas como:
    Ej.
        const routes = [
            {
                path: '/',
                component: HomePage
            },
            {
                path: '/about',
                component: AboutPage
            }
        ]
    Creamos la función de nuestro Router que hace lo que ya teníamos en nuestra App para las SPA añadiendo un control para establecer la Page a renderizar según nuestras rutas
    y el estado currentPath:
    Ej.
        function Router ({ routes = [], defaultComponent: DefaultComponent = () => <h1>404 Not Found</h1> }) {
            const [currentPath, setCurrentPath] = useState(window.location.pathname)

            useEffect(() => {
                const onLocationChange = () => {
                   setCurrentPath(window.location.pathname)
                } 

                // Escuchamos el evento de navegación
                window.addEventListener(EVENTS.PUSHSTATE, onLocationChange)
                // Escuchamos el evento del navegador cuando damos al boton de ir para atrás
                window.addEventListener(EVENTS.POPSTATE, onLocationChange)

                return () => {
                    // Limpiamos el evento al desmontar el componente
                    window.removeEventListener(EVENTS.PUSHSTATE, onLocationChange)
                    // Escuchamos el evento del navegador cuando damos al boton de ir para atrás
                    window.addEventListener(EVENTS.POPSTATE, onLocationChange)
                }
            }, [])

            const Page = routes.find(route => route.path === currentPath)?.component    => indicamos el componente a renderizar segun la ruta encontrada
            return Page ? <Page /> : <DefaultComponent />                               => si lo hemos encontrado lo renderizamos, sino el por defecto
            }

192. Modificamos ya nuestro renderizado de main con las rutas:
    Ej.
        function App() {
            return (
                <main>
                    <Router routes={routes} />
                </main>
            )
        }

193. Separamos nuestra función Router a un componente Router.jsx y simplificamos nuestro componente App.jsx:
    Ej.
        import './App.css'
        import HomePage from './pages/Home'
        import AboutPage from './pages/About'
        import {Router} from './Router'

        const routes = [
            {
                path: '/',
                component: HomePage
            },
            {
                path: '/about',
                component: AboutPage
            }
        ]

        function App() {
            return (
                <main>
                    <Router routes={routes} />
                </main>
            )
        }

        export default App

194. Una ruta protegida se consigue simplemente añadiendo un if:
    Ej.
        function App() {
            const [currentPath, setCurrentPath] = useState(window.location.pathname)
            const isAuthenticated = true // o false, según tu lógica

            return (
                <main>
                    {currentPath === '/' && <HomePage />}
                    {currentPath === '/about' && <AboutPage />}
                    {currentPath === '/profile' && (
                        isAuthenticated
                        ? <ProfilePage />
                        : <p>Debes iniciar sesión para ver esta página</p>
                    )}
                </main>
            )
        }

195. IMPORTANTE: si quieres que tu pantalla se situa al principio de todo al mostrarse:
    Ej.
        window.scrollTo( 0, 0 )

    Esto se podría aplicar en el Link:
    Ej.
        export function Link({ resetScroll, target, to, ...props }) {           => añadimos un booleano resetScroll
            const handleClick = (event) => {
                // tenemos en cuenta las teclas que se pueden combinar con el click
                const isMainEvent = event.button === BUTTONS.primary    
                const isModifiedEvent = event.metaKey || event.altKey || event.ctrlKey || event.shiftKey    
                const isManageableEvent = target === undefined || target === '_self' || target === ''    

                if(isMainEvent && isManageableEvent && !isModifiedEvent) {
                    // Prevenir el comportamiento por defecto del enlace
                    event.preventDefault()           
                    // navegacion con SPA
                    navigate(to) 
                    // si tenemos que hacer el reset del scroll lo hacemos
                    resetScroll && window.scrollTo( 0, 0 )
                }
            }

            return <a onClick={handleClick} href={to} target={target} {...props} />
        }

196. Para instalar rutas con parámetros o dinámicas necesitamos instalar una dependencia:  npm install path-to-regexp -E
    Esto instala path to regex que es una de las librerías más famosas de node.js
    Una ruta dinámica sería del tipo:
    Ej.
        const appRoutes = [
            {
                path: '/',
                component: HomePage
            },
            {
                path: '/about',
                component: AboutPage
            },
            {
                path: '/search/:query',                   => ruta dinámica
                component: () => <h1>Search Page</h1>
            }
        ]

    Modificamos nuestro Router para buscar en la url con match de regex y ver si encuentra la ruta dentro de las válidas:
    Ej.
        import { useEffect, useState } from 'react'
        import { EVENTS } from './consts'
        import { match } from 'path-to-regexp'

        export function Router ({ routes = [], defaultComponent: DefaultComponent = () => <h1>404 Not Found</h1> }) {
            const [currentPath, setCurrentPath] = useState(window.location.pathname)

            useEffect(() => {
                const onLocationChange = () => {
                    setCurrentPath(window.location.pathname)
                } 

                // Escuchamos el evento de navegación
                window.addEventListener(EVENTS.PUSHSTATE, onLocationChange)
                // Escuchamos el evento del navegador cuando damos al boton de ir para atrás
                window.addEventListener(EVENTS.POPSTATE, onLocationChange)

                return () => {
                    // Limpiamos el evento al desmontar el componente
                    window.removeEventListener(EVENTS.PUSHSTATE, onLocationChange)
                    // Escuchamos el evento del navegador cuando damos al boton de ir para atrás
                    window.addEventListener(EVENTS.POPSTATE, onLocationChange)
                }
            }, [])

            let routeParams = {}
            const Page = routes.find(({path}) => {
                if(path === currentPath) return true

                const matcherUrl = match( path, { decode: decodeURIComponent })     => busqueda del path con un parámetro de configuración decodeURIComponent
                const matched = matcherUrl(currentPath)                             => mira si para el currentpath encontramos una ruta que cumpla el matcherUrl
                if (!matched) return false                                          => no la encuentra

                routeParams = matched.params    // ej. { query: 'javascript' }      => pasamos los parámetros de la busqueda que ha sido ok        
                return true                                                         => encontrada
            })?.component

            return Page ? <Page routeParams={routeParams} /> : <DefaultComponent routeParams={routeParams} />   => le pasamos los parámetros de la búsqueda a la Page a renderizar
        }

    Por último ya podemos presentar o acceder a los parámetros en el propio componente renderizado:
    Ej.
        const appRoutes = [
            {
                path: '/',
                component: HomePage
            },
            {
                path: '/about',
                component: AboutPage
            },
            {
                path: '/search/:query',                   
                component: ({routeParams}) => <h1>Search Page {routeParams.query}</h1>
            }
        ]

197. **> CLAVE <** ==>> Si ponemos   const Page = routes.find(condicion)?.component si la parte de la izquierda del ? es null ya no se evalua la parte de la derecha
    Evitando la petada por ser null que da al intentar acceder a un atributo que es null.

198. **> CLAVE <** ==>> Las queryStrings no deben formar parte a nivel de renderizado de nuestro router, son algo a parte del renderizado, son parámetros para la página y
    no necesariamente para renderizar. Es una mala práctica relacionar el renderizado con las queryStrings.

199. **> CLAVE <** ==>> en react podemos traer unas utilidades para iterar con children, están en la librería Children.
    Ej.
        import { useEffect, useState, Children } from 'react'
    Nos permiten usar map, toArray, y otras opciones sobre los children.
    En este ejemplo podemos ver como leemos las props de los children:
    Ej.
        const routesFromChildren = Children.map(children, ({props, type}) => {
            const {name} = type
            const isRoute = name === 'Route' || name === 'RouteWithParams'

            return isRoute ? props : null
        })

200. **> CLAVE <** ==>> routesFromChildren.filter(Boolean) : esto filtra el array routesFromChildren eliminando todos los elementos que son false (es decir: false, 
    null, undefined, 0, '', NaN). En JavaScript, pasar Boolean como argumento a .filter() es un truco común para limpiar un array de valores no válidos.

201. **> CLAVE <** ==>> la carga tardía de páginas o componentes es importante por rendimiento, ya que si en nuestra App tenemos imports de los componentes o páginas que vamos a renderizar en 
    nuestras rutas cuando accedamos, aunque no se muestre nada más que el primero se cargarán todos.
    Para solucionar este problema usamos la función lazy de react 
    Ej.
        import { lazy } from 'react'
    Entonces en lugar de hacer imports estáticos de nuestras páginas y componentes lo hacemos de forma dinámica y solo se importará cuando lo queremos usar:
    Ej.
        // imports estáticos
        import HomePage from './pages/Home'
        import AboutPage from './pages/About'

        // imports dinámicos
        const LazyHomePage = lazy(() => import('./pages/Home.jsx'))
        const LazyAboutPage = lazy(() => import('./pages/About.jsx'))

    De esta forma LazyHomePage se puede usar en cualquier parte del App, pero solo se importará la primera vez que se llame para renderizar. Pero hay que envolver los 
    componentes con el componente <Suspense> porque hay que indicarle que falta una parte de código por cargar:
    Ej.
        function App() {
            return (
                <main>
                    <Suspense fallback={<h1>Loading...</h1>}>               => el fallback es para mostrar algo mientras cargamos
                        <Router routes={appRoutes}>
                        <Route path='/' component={LazyHomePage} />
                        <Route path='/about' component={LazyAboutPage} />
                        </Router>
                    </Suspense>
                </main>
            )
        }
    
202. **> CLAVE <** ==>> TESTING con VITEST
    1. Instalamos la dependencia: npm install vitest -D
    2. Modificamos el package.json añadiendo vitest:
        Ej.
            "scripts": {
                "dev": "vite",
                "build": "vite build",
                "lint": "eslint .",
                "preview": "vite preview",
                "test": "vitest"
            },
    3. Creamos un test de prueba en un fichero NNNNNNN.test.jsx  donde NNNNNNN es el nombre del fichero, por ejemplo Router.test.jsx
        Ej.
            import { describe, it, expect } from "vitest";
            describe("Router", () => {  
                it("should work", () => {
                    expect(1).toBe(1); 
                });
            })
    4. Ejecutamos el test: 
        Ej.
            npm run test
        Resultado:
            ✓ src/Router.test.jsx (1 test) 4ms
            ✓ Router > should work 2ms

            Test Files  1 passed (1)
                Tests  1 passed (1)
            Start at  22:15:26
            Duration  657ms (transform 182ms, setup 0ms, collect 156ms, tests 4ms, environment 0ms, prepare 187ms)

            PASS  Waiting for file changes...
    5. Instalamos algunas herramientas:
        Ej.
            npm install happy-dom @testing-library/react -D
    6. En el vite.config.js ponemos para test:
        Ej.
            import { defineConfig } from 'vite'
            import react from '@vitejs/plugin-react-swc'

            // https://vitejs.dev/config/
            export default defineConfig({
                plugins: [react()],
                test: {
                    environment: 'happy-dom'
                }
            })
    7. Hacemos un test real de renderizado con las rutas en vacío:
        Ej.
            import { describe, it, expect } from "vitest";
            import { render } from "@testing-library/react";        // importar la funcion render
            import { Router } from "./Router";

            describe("Router", () => {  
                it("should render without problems", () => {
                    render(<Router routes={[]} />);             // render con las rutas en vacío
                });
            })
    8. Ejecutamos el test:
        Ej.
            npm run test
        Resultado:
             DEV  v3.2.4 C:/Users/Jose/Documents/practicasReact/midu-router

            ✓ src/Router.test.jsx (1 test) 22ms
            ✓ Router > should render without problems 20ms

            Test Files  1 passed (1)
                Tests  1 passed (1)
            Start at  22:42:05
            Duration  1.70s (transform 71ms, setup 0ms, collect 418ms, tests 22ms, environment 754ms, prepare 185ms)

            PASS  Waiting for file changes...
                press h to show help, press q to quit
    9. Añadimos un test de pantalla revisando el contenido con screen:
        Ej.
            import { describe, it, expect } from "vitest";
            import { render, screen } from "@testing-library/react";        // importar la funcion screen
            import { Router } from "./Router";

            describe("Router", () => {  
                it("should render without problems", () => {
                    render(<Router routes={[]} />);             // render con las rutas en vacío
                });

                it('should render 404 if no routes match', () => {
                    render(<Router routes={[]} defaultComponent={() => <h1>404</h1>} />)    => renderiza el defaultComponent al poner rutas vacías
                    expect(screen.getByText('404')).toBeTruthy()                            => comprueba que en pantalla tengamos este mensaje: 404
                })
            })
    10. ejecutamos los test:
        Ej.
            npm run test
        Resultado:
             DEV  v3.2.4 C:/Users/Jose/Documents/practicasReact/midu-router

            ✓ src/Router.test.jsx (2 tests) 29ms
            ✓ Router > should render without problems 20ms
            ✓ Router > should render 404 if no routes match 8ms

            Test Files  1 passed (1)
                Tests  2 passed (2)
            Start at  22:50:50
            Duration  1.69s (transform 74ms, setup 0ms, collect 429ms, tests 29ms, environment 736ms, prepare 183ms)

            PASS  Waiting for file changes...
                press h to show help, press q to quit
    11. añadimos un método de limpiado que se ejecutará antes de cada test:
        Ej.
            import { describe, it, expect, beforeEach } from "vitest";
            import { render, screen, cleanup } from "@testing-library/react";   // traemos cleanup
            import { Router } from "./Router";

            describe("Router", () => {  
                beforeEach(() => {
                    cleanup();  // limpia el DOM antes de cada test
                });
                it("should render without problems", () => {
                    render(<Router routes={[]} />);  // render con las rutas en vacío
                    expect(true).toBeTruthy();         
                });

                it('should render 404 if no routes match', () => {
                    render(<Router routes={[]} defaultComponent={() => <h1>404</h1>} />)    // renderiza el defaultComponent al poner rutas vacías
                    expect(screen.getByText('404')).toBeTruthy()                            // comprueba que en pantalla tengamos este mensaje: 404
                })
            })
    12. Recomendado instalar la extensión:
            Vitest
            vitest.dev            
            A Vite-native testing framework. It's fast!

            Vitest se puede utilizar con mas entornos no solo con vite, pero por dentro lleva vite.

    13. Hacemos un test para verificar nuestras rutas, pero tenemos el problema de simular el path correcto de nuestras rutas, por lo que seguramente nos petaría.
        Para ello hacemos uso de una utilidad:
            Ej.
                it('should render the component of the first route that matches', () => {                    
                    const routes = [
                    {
                        path: '/',
                        Component: () => <h1>Home</h1>
                    },
                    {
                        path: '/about',
                        Component: () => <h1>About</h1>
                    }
                    ]

                    render(<Router routes={routes} />)
                    expect(screen.findByText('About')).toBeTruthy()
                })

            Este test no funcionará y dará error por las rutas.
        Si vamos a la línea en la que obtenemos el path en la aplicación vemos:
            Ej.
                const [currentPath, setCurrentPath] = useState(window.location.pathname)
        Vamos a exportar este path mediante una utilidad en utils.js:
            Ej.
                export const getCurrentPath = () => window.location.pathname
        Ahora cambiamos las apariciones del window.location.pathname por la llamada a nuestra utilidad:
            Ej.
                const [currentPath, setCurrentPath] = useState(getCurrentPath())
            Ej.
                useEffect (() => {
                    const onLocationChange = () => {
                        setCurrentPath(getCurrentPath())
                    }
                }
                ...
                }, [])
        Ahora podemos importar ese método en nuestro archivo de test:
            Router.test.jsx
            Ej.
                import { getCurrentPath } from './utils.js'
        Tambien importamos la utilidad vi de vitest que nos permitirá mockear:
            Ej. 
                import { describe, it, expect, beforeEach, vi } from "vitest";

                vi.mock('./utils/getCurrentPath.js', () => ({
                  getCurrentPath: vi.fn()                       => le decimos que en vez de la función que era es una función de vi, a la que podremos cambiar cuando queramos el valor devuelto
                }))

        En el beforeEach borramos todos los mocks anteriores que tengamos:
            Ej.
                describe('Router', () => {
                    beforeEach(() => {
                        cleanup()
                        vi.clearAllMocks()
                    })
                    ...
                )
        Ahora podemos modificar nuestro path justo antes de cada test:
            Ej.
                it('should render the component of the first route that matches', () => {
                    getCurrentPath.mockReturnValue('/about')       // le indicamos que es /about haciendo cierto el test

                    const routes = [
                    {
                        path: '/',
                        Component: () => <h1>Home</h1>
                    },
                    {
                        path: '/about',
                        Component: () => <h1>About</h1>
                    }
                    ]

                    render(<Router routes={routes} />)
                    expect(screen.findByText('About')).toBeTruthy()   // usamos findByText porque es asíncrono y tiene el await, mientras que el getByText no
                })
            
    14. Podemos añadir el script test:ui al package.json que nos permitirá ver un control de los tests que tenemos y ejecutarlos y demás en un entorno gráfico dentro de chrome:
        Ej. Package.json
            "scripts": {
            "dev": "vite",
            "build": "vite build",
            "lint": "eslint .",
            "preview": "vite preview",
            "test": "vitest",
            "test:ui": "vitest --ui"
        }, 

        Luego ejecutamos desde el terminal npm run test:ui y nos abrirá con el explorador una opción 

    15. Para probar el Link y que podemos saltar entre páginas hacemos el último test:
        Ej.
            import { describe, it, expect, beforeEach, vi } from 'vitest'
            import { render, screen, cleanup, fireEvent } from '@testing-library/react'
            import { Router } from './components/Router.jsx'
            import { Route } from './components/Route.jsx'
            import { Link } from './components/Link.jsx'
            import { getCurrentPath } from './utils/getCurrentPath.js'

            it('should navigate using Links', async () => {
                getCurrentPath.mockReturnValueOnce('/')     // OJO este solo mockea el valor de la función una vez

                render(
                <Router>
                    <Route
                    path='/' Component={() => {
                        return (
                        <>
                            <h1>Home</h1>
                            <Link to='/about'>Go to About</Link>
                        </>
                        )
                    }}
                    />
                    <Route path='/about' Component={() => <h1>About</h1>} />
                </Router>
                )

                // Click on the link
                const anchor = screen.getByText(/Go to About/)
                fireEvent.click(anchor)

                const aboutTitle = await screen.findByText('About')

                // Check that the new route is rendered
                expect(aboutTitle).toBeTruthy()
            })      

203. PUBLICAR el proyecto:
    Se trata de publicarlo como un paquete que podamos utilizar desde cualquier sitio.
    
    1. Modificamos el package.json añadiendo el script prepare:
        Ej.
            "scripts": {
            "dev": "vite",
            "build": "vite build",
            "prepare": "",
            "lint": "eslint .",
            "preview": "vite preview",
            "test": "vitest",
            "test:ui": "vitest --ui"
        },

        Usaremos el prepare para preparar el despliegue.

    2. Vamos a instalar SWC que es una alternativa a Babel que te permite compilar tus ficheros para que puedas utilizarlos sin un compilador.
        Ej.
            npm install @swc/cli @swc/core -D
        
    3. Ejecutamos el swc:
        Usamos npx para ejecutar un paquete sin instalarlo globalmente o para ejecutar scripts definidos en package.json
        Ej.
            npx swc ./src/Router.jsx
        
    4. Queremos renderizar todos los ficheros jsx del src:
        Ej.
            npx swc src -d lib

        Esto los pone en el directorio lib

        Nos da error porque hay que adaptar el SWC con un archivo de configuración para cambiar sus valores por defecto:
        
        El error ocurre porque SWC no soporta JSX por defecto en archivos .jsx si no tienes configurado el parser para JSX.
        Además, SWC no soporta fragmentos (<>...</>) ni JSX avanzado sin configuración adicional.

        **> CLAVE <** ==>> ¿Por qué te da errores como "Expression expected"?
            SWC necesita que le indiques que el parser debe soportar JSX.
            Si usas fragmentos (<>...</>), asegúrate de que el parser está configurado para soportarlos.
            SWC no transpila código de test (.test.jsx) ni código React moderno sin configuración adecuada.

        **> CLAVE <** ==>> ¿Cómo solucionarlo?
            1. Crea un archivo de configuración para SWC 
                Crea un archivo llamado .swcrc en la raíz de tu proyecto con este contenido: .swcrc
                Ej.
                    {
                        "jsc": {
                            "parser": {
                                "syntax": "ecmascript",
                                "jsx": true
                            },
                            "transform": {
                                "react": {
                                    "runtime": "automatic"
                                }
                            }
                        }
                    }
                Esto le dice a SWC que soporte JSX y React moderno.


    5. Ponemos esta instrucción en el script prepare de nuestro package.json
        Ej.
            "scripts": {
            "dev": "vite",
            "build": "vite build",
            "prepare": "npx swc src -d lib",
            "lint": "eslint .",
            "preview": "vite preview",
            "test": "vitest",
            "test:ui": "vitest --ui"
        },

        **> CLAVE <** ==>> prepare es un script especial en nuestro package.json que se ejecuta justo antes de nuestro publish

    6. En nuestro package.json indicamos la versión y el main que será nuestro punto de entrada:
        Ej.
            "version": "0.0.1",
            "main": "lib/index.js",
            "module": "lib/index.js",
            "type": "module",

        Tendremos que crear el src/index.jsx 
            Ej.
                export { Router } from './components/Router'
                export { Link } from './components/Link'
                export { Route } from './components/Route'

    7. Para poder borrar los ficheros que nos interesan que no aparezcan ya que el --ignore no parece funcionar y los genera como el App.js o el main.js 
        Ej.
            npm install -D rimraf
        En el prepare del package.json pongo:
        Ej.
            "prepare": "swc src -d lib && rimraf --glob lib/**/*.test.js lib/**/*.spec.js lib/**/main.js lib/**/App.js"
        Al instalar rimraf o en algun otro momento se ha desconfigurado swc y he tenido que volver a instalarlo (paso 2)
    8. Para poder copiar los ficheros de js restantes como consts.js
        Ej.
            npm install -D cpx
        En el prepare usamos cpx

    9. Probamos si funciona el script: prepare
        Ej.
            npm run prepare
    10. Cambiamos las dependencias para que react y react-dom pasen a no instalarlas nosotros sino que ya estén instaladas en el entorno donde despleguemos: peerDependencies
        Ej.
            "dependencies": {
                "path-to-regexp": "8.2.0",
                "react": "^19.1.0",
                "react-dom": "^19.1.0"
            },
        Lo modificamos como:
            "dependencies": {
                "path-to-regexp": "8.2.0"
            },
            "peerDependencies": {
                "react": "^19.1.0",
                "react-dom": "^19.1.0"
            },
    11. Podemos decirle a nuestro swc que minifique los archivos:
        Ej. modificamos el .swcrc con: "minify": true
            {
                "$schema": "https://json.schemastore.org/swcrc",
                "jsc": {
                    "parser": {
                        "syntax": "ecmascript",
                        "jsx": true,
                        "dynamicImport": false,
                        "privateMethod": false,
                        "functionBind": false,
                        "exportDefaultFrom": false,
                        "exportNamespaceFrom": false,
                        "decorators": false,
                        "decoratorsBeforeExport": false,
                        "topLevelAwait": false,
                        "importMeta": false
                    },
                    "transform": {
                        "react": {
                            "runtime": "automatic"
                        }
                    },
                    "target": "es2020",
                    "loose": true,
                    "externalHelpers": false,
                    // Requires v1.2.50 or upper and requires target to be es2016 or upper.
                    "keepClassNames": false
                },
                "minify": true
            }

    12. Podemos crear un fichero .npmignore en la raiz del proyecto para evitar que publique archivos no necesarios:
        Ej. 
            src
            public
    
    13. Para poder hacer un publish desde npm necesitas tener una cuenta y hacer npm login:
        - Creamos la cuenta:
            Ej.
                npm login
                Esto nos lleva a poner las credenciales: usuario: vangeyper,  clave: React?????
                Nos pedirá por correo un codigo de segundo factor de autenticación.
                Con eso entramos en npm y ya podemos publicar en nuestro entorno visual studio code:
                
                npm publish
                
                    > midu-router-jose@0.0.13 prepare
                    > npx swc src -d lib && rimraf --glob lib/**/*.test.js lib/**/*.spec.js lib/**/main.js lib/**/App.js && cpx "src/*.js" lib/

                    Successfully compiled: 12 files with swc (118.63ms)
                    npm notice
                    npm notice 📦  midu-router-jose@0.0.13
                    npm notice Tarball Contents
                    npm notice 857B .swcrc
                    npm notice 237B .vscode/launch.json
                    npm notice 856B README.md
                    npm notice 844B eslint.config.js
                    npm notice 436B index.html
                    npm notice 122B lib/consts.js
                    npm notice 1.1kB package.json
                    npm notice 209B vite.config.js
                    npm notice Tarball Details
                    npm notice name: midu-router-jose
                    npm notice version: 0.0.13
                    npm notice filename: midu-router-jose-0.0.13.tgz
                    npm notice package size: 2.3 kB
                    npm notice unpacked size: 4.7 kB
                    npm notice shasum: 16de27e84dac5eec43b4fefc1495935e1afc46ad
                    npm notice integrity: sha512-SMj2FajAIeNjx[...]bNLf+5FalCjTA==
                    npm notice total files: 8
                    npm notice
                    npm notice Publishing to https://registry.npmjs.org/ with tag latest and default access
                    + midu-router-jose@0.0.13

    14. Accedemos a nuestra publicación mediante la url: https://www.npmjs.com/package/midu-router-jose
        Donde midu-router-jose es el name de nuestro package.json
        Cualquier persona lo puede instalar ahora solo con 
        Ej.
            npm install midu-router-jose

204. Un Custom hook que permitiría capturar todos los parámetros de una query ya sea servidor o cliente sería algo parecido a:
    Ej.
        function useQueryParams ({ req } = {}) {
            const isServer = typeof window === 'undefined'
            if (isServer) {
                const { query } = req
                return query
            }

            const search = window.location.search
            const params = new URLSearchParams(search)
            return Object.fromEntries(params.entries())
        }

        export default function SearchPage ({ routeParams }) {
            const { limit } = useQueryParams()
            console.log(limit)
            
            useEffect(() => {
                document.title = `Has buscado ${routeParams.query}`
            }, [])

            return (
                <h1>Has buscado {routeParams.query}</h1>
            )
        }


---------------------------------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------------------------------- 