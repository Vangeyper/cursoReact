
CURSO REACT 2024 - Aprende desde cero  
Curso https://www.youtube.com/watch?v=7iobxzd_2wY   
---------------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------------

1. Importante: se usa para todas las partes : cliente y servidor. Es una biblioteca y la podemos usar desde javascript sin empaquetadores como VITE.
2. IMPORTANTE: web para consultas de todos los niveles: reactjs.wiki
3. Se crea en 2011 para solventar la problematica de interfaces graficas de formularios y con el objetivo de impedir los ataques por XSS
4. Con lo que aprendes de React Native también se pueden diseñar aplicaciones móviles.
5. También se utiliza en aplicaciones de escritorio. Microsoft ha hecho React Native for Windows + macOS
6. Soporte asegurado.
7. Tiene una API estable en el tiempo. No hay grandes modificaciones en el tiempo.
8. Comunidad inmensa.
9. Con Vanilla Javascript el código para hacer por ejemplo un boton que al pulsarlo cambie su texto es IMPERATIVO: le decimo el cómo hacerlo.
10. Si tengo varios botones en código IMPERATIVO no escala bien, estop suele ser siempre así.

11. Podemos inyectar cualquier componente react en cualquier parte de nuestra aplicación.
12. Ej.
        <div id="app"></div>

    import ReactDOM from "https://esm.sh/react-dom@18.2.0/client"
    const app = document.getElementById('app')
    const root = ReactDOM.createRoot(app)           -> react es un conjunto de componentes en forma organizativa de árbol, por eso creamos el root o raiz
    root.render('un texto')     -> funciona
    root.render('<button>Guardar</button>')         -> NO funciona como html, lo pone como texto para evitar las inyecciones XSS

13. Para poder renderizar un html requerimos crear un element y debemos importar React:
    Ej.
        import React from "https://esm.sh/react-dom@18.2.0"

        const button = React.createElement('button', { "data-id": 123 }, 'Guardar')      -> el tercer parámetro es el envoltorio, y el segundo los atributos
        root.render(button)     -> esto si renderiza un botón con el atributo data-id y el valor para el mismo de 123

14. Si ahora queremos crear 3 botones y renderizarlos:
    Ej.
        const button1 = React.createElement('button', { "data-id": 123 }, 'Guardar 1')    
        const button2 = React.createElement('button', { "data-id": 456 }, 'Guardar 2')
        const button3 = React.createElement('button', { "data-id": 789 }, 'Guardar 3')
        root.render(button1, button2, button3)     -> esto NO renderiza los botones porque solo podemos renderizar 1 elemento al mismo tiempo

15. Una forma de hacer el renderizado de los 3 botones sería envolviéndolos en un div y renderizándolo:
    Ej.
        const button1 = React.createElement('button', { "data-id": 123 }, 'Guardar 1')    
        const button2 = React.createElement('button', { "data-id": 456 }, 'Guardar 2')
        const button3 = React.createElement('button', { "data-id": 789 }, 'Guardar 3')
        const div = React.createElement('div', null, [button1, button2, button3])
        root.render(div)

16. Pero esto creará un div en nuestro html, y no queremos eso:
    En react podemos crear un envoltorio vacio con React.Fragment:
    Ej.
        const div = React.createElement(React.Fragment, null, [button1, button2, button3])
        root.render(div)

    Esto renderiza los 3 botones pero sin poner un div adicional.

17. El problema es que no hemos conseguido tener un código completamente DECLARATIVO, en la parte de createElement le estamos diciendo de forma IMPERATIVA lo que hay que hacer.
    Para tenerlo en declarativo debemos usar JSX:
    Esto es una extensión de Javascript que nos permite mediante algo similar al xml poner nuestra interfaz en formato declarativo:
    Ej.
        <React.Fragment>
            <button data-id="123">Button 1</button>
            <button data-id="456">Button 2</button>
            <button data-id="789">Button 3</button>
        </React.Fragment>
    Si ponermos root.render(
        <button data-id="123">Button 1</button>
        <button data-id="456">Button 2</button>
    )
    petará porque solo espera un parámetro, un element. Por eso usamos el React.Fragment para envolver a todos los botones y pasarlo como un único element.

    Esto equivale a lo que teníamos antes:
    Ej.
        const button1 = React.createElement('button', { "data-id": 123 }, 'Guardar 1')    
        const button2 = React.createElement('button', { "data-id": 456 }, 'Guardar 2')
        const button3 = React.createElement('button', { "data-id": 789 }, 'Guardar 3')
        const div = React.createElement(React.Fragment, null, [button1, button2, button3])
        root.render(div)

18. IMPORTANTE: la transformación de JSX a el código javascript normal la hace mediante 2 herramientas: BABEL y SWC    
    Es decir, el JSX es Javascript, pero mucho más entendible que el resultado final de teclearlo de la forma tradicional.

19. JSX:
    19.1. Expresiones (poniendo la const o variable entre llaves):
        Ej. 
            const name = 'Miguel'
            <h1>Hola, {name}>

        Se puede hacer lo mismo con funciones
        Ej.
            const element = <strong>Número aleatorio. {Math.random()}</strong>
        Entre las {} solo podemos tener expresiones, NO declaraciones, por ejemplo un if no se puede.

    19.2. Curiosidad: los atributos en JSX al ser Javascript y no html se nombran con la nomenclatura CamelCase
        Ej.
            <button tabIndex="1">     -> no se pone tab-index
    
20. Para hacer una app con react usaremos un empaquetador de aplicaciones:
    20.1. Usar: npx create-react-app.dev my-app
                cd my-app
                npm start
        Esto utiliza webpack que ahora ya está superado como empaquetador.
    20.2. Usar Vite:
        npm init -y
        mkdir projects
        cd projects
        npm create vite@latest
            Preguntará nombre del proyecto: 00-hola-mundo
            React
            TypeScript o JavaScript + SWC
        cd 00-hola-mundo
        npm install
        npm run dev

        Vite ya detecta archivos con JSX y los transpila con SWC a Javascript.
    
21. PRIMER PROYECTO:
    Importante ver que en nuestro index.html tenemos el root e incluímos el punto de entrada de nuestra app:
    Ej.
        <body>
            <div id="root"></div>
            <script type="module" src="/src/main.jsx"></script>  -> punto de entrada
        </body>

    En nuestro main.jsx tenemos:
    Ej.
        import React from 'react'
        import ReactDOM from 'react-dom/client'
        import App from './App'
        import './index.css'

        ReactDOM.createRoot(document.getElementById('root')).render(
            <React.StrictMode>
                <App />
            </React.StrictMode>
        )

22. para poner varios botones con código repetido lo que necesitamos es crear un Componente que tenga algunas cosas que cambian pero la base se
    reutilice. COMPONENTE: es una función que crea un elemento que luego podemos reutilizar.

23. Podríamos haber creado una función de creación del botón y llamarla 3 veces:
    Ej.
        const createButton = ({text}) => {
            // aquí podríamos darle estilos, añadir iconos y complicarlo todo lo que quisieramos
            <button>{text}</button>
        }
    
        root.render(
            <React.Fragment>
                {createButton({ text: 'Button 1' })}
                {createButton({ text: 'Button 2' })}
                {createButton({ text: 'Button 3' })}
            </React.Fragment>
        )

    Pero esto aunque estaría bien sigue siendo IMPERATIVO y no DECLARATIVO como hemos dicho que pretende React.

24. Para hacer el componente del button en react sería de esta forma:
    Ej.
        Le ponemos un nombre al componente, no le indicamos que lo vamos a crear:
        const Button = ({text}) => {
            // aquí podríamos darle estilos, añadir iconos y complicarlo todo lo que quisieramos
            <button>{text}</button>
        }

        Y para indicar que queremos tener 3 botones lo hacemos de forma declarativa:

        root.render(
            <React.Fragment>
                <Button text = 'Button 1'></Button>
                <Button text = 'Button 2'></Button>
                <Button text = 'Button 3'></Button>
            </React.Fragment>
        )

25. IMPORTANTE: los componentes tienes que seguir la nomenclatura Pascal Case. Esto es porque react no es capaz de diferenciar entre componentes y elementos html en caso de no cumplir con esta nomenclatura. 
    Al empezar con mayúsculas sabe que es un componente. 
    Para ver la diferencia de nomenclaturas:
        PascalCase
        camelCase    
        snake_case
        kebab-case

26. ESTILOS en react:
    Se pueden importar archivos css
    También podemos usar estilos en línea, pero en lugar de ponerlos como un string debemos hacerlo como un objeto:
    Ej.
        <article style={{ display: 'flex', alignItems: 'center'}}></article>
    Lo correcto es usar importacion de archivos css, pero a veces no se puede y hay que usar los estilos en línea. 
    También en react native habrá que usar estilos en línea.

27. IMPORTANTE: para determinar o indicar la clase en un elemento debemos utilizar className, puesto que class es una palabra reservada de Javascript.

28. Para los estilos podemos usar BEM o SUIT. Puedes aplicar CSS Modules

29. IMPORTANTE: existe una web con componentes de react ya creados y estilados: chakra-ui.com

30. IMPORTANTE: un componente será reutilizable si podemos pasarle propiedades o parámetros para poder adaptarlo a nuestra necesidad. Si no tienen parámetros no es reutilizable, siempre será único.

31. IMPORTANTE: Para devolver más de un elemento en react tenemos que utilizar el React.Fragment envolviéndolos, pero existe un atajo:
        <> ...elementos... </>   es lo mismo que poner <React.Fragment> ...elementos... </React.Fragment>

32. Cuando estilamos hay que tener presente que no pongamos estilos para arreglar un componente en el contexto actual pero que en otro contexto no quedaría bien, por ejemplo un margin-top de un elemento.
    Para eso es mejor estilar el componente padre, o hacerlo de manera que siempre se vea bien.

33. IMPORTANTE: para pasar un parámetro booleano a un componente:
    1. Si le pasamos "true" lo interpreta como un string que escribe true no como booleano.
    2. Hay que interpretarlo poniendolo entre llaves: {true}
        Ej.
            <TwitterFollowCard
                key="key"
                userName="nombre"
                initialIsFollowing={false}
                >
                "Nombre"
            </TwitterFollowCard>
    3. Podemos ahorrarnos las llaves si le pasamos directamente una variable booleana
        Ej.
            <TwitterFollowCard
                key="key"
                userName="nombre"
                initialIsFollowing
                >
                "Nombre"
            </TwitterFollowCard>
    4. No podemos pasarle un negado de una variable booleana.
        Ej.
            <TwitterFollowCard
                key="key"
                userName="nombre"
                !initialIsFollowing
                >
                "Nombre"
            </TwitterFollowCard>
        Esto da error, hay que pasarle el {false}

34. IMPORTANTE: también podemos pasarle funciones como props o parámetros al componente. Las funciones en javascript son de primera clase, con lo que podemos pasarlas como parámetros.
    OJO: no es lo mismo pasar la función que pasar la ejecución de la función. Para pasar la ejecución es miFuncion = {funcionName()} mientras que para pasar la función es miFuncion = {funcionName}
    donde funcionName es el nombre de la función.

35. CLAVE ==>>  ¿ cuál es la diferencia entre un ELEMENTO y un COMPONENTE ?: un componente es como una factoría de elementos, es una función que al ejecutarla te devuelve un elemento.

36. IMPORTANTE: las props deberían ser inmutables => no debemos modificar el valor de las props dentro del componente. Lo correcto es hacer una copia en una constante o variable y luego modificarla.

37. CLAVE ==>> CHILDREN: es una prop especial que hace referencia a todos los hijos de un elemento, pueden ser uno o varios.
    Ej.
        <TwitterFollowCard
            key={userName}
            userName={userName}
            initialIsFollowing={isFollowing}
            >
            {name}                  -> esto sería el children
        </TwitterFollowCard>

    En el componente podemos acceder a la prop como children:
    Ej.
        export function TwitterFollowCard ({ children, userName, initialIsFollowing }) {
        const [isFollowing, setIsFollowing] = useState(initialIsFollowing)

        console.log('[TwitterFollowCard] render with userName: ', userName)

        const text = isFollowing ? 'Siguiendo' : 'Seguir'
        const buttonClassName = isFollowing
            ? 'tw-followCard-button is-following'
            : 'tw-followCard-button'

        const handleClick = () => {
            setIsFollowing(!isFollowing)
        }

        return (
            <article className='tw-followCard'>
            <header className='tw-followCard-header'>
                <img
                className='tw-followCard-avatar'
                alt='El avatar de midudev'
                src={`https://unavatar.io/${userName}`}
                />
                <div className='tw-followCard-info'>
                <strong>{children}</strong>
                <span className='tw-followCard-infoUserName'>@{userName}</span>
                </div>
            </header>

            <aside>
                <button className={buttonClassName} onClick={handleClick}>
                <span className='tw-followCard-text'>{text}</span>
                <span className='tw-followCard-stopFollow'>Dejar de seguir</span>
                </button>
            </aside>
            </article>
            )
        }
        
    En ese caso es un texto el contenido de children con el nombre.

38. IMPORTANTE: normalmente lo más importante de un componente que además quieres que sea extensible y modificable al máximo debería ser un children.
    No indicar children como un paso de prop normal, solo hace falta ponerlo en el componente no en el paso de parámetros, puesto que ya tienen entidad por sí sola.

39. Se pueden pasar todas las props en un objeto mediante Rest Operator:
    Ej.
        const midu = {isFollowing: false, userName: 'midudev'}
        const ferap = {isFollowing: true, userName: 'ferap'}

        return (
            <section className="App"
                <TwitterFollowCard
                        {...midu}
                    >
                    Miguel Angel
                </TwitterFollowCard>
                <TwitterFollowCard
                        {...ferap}
                    >
                    Pedro Santos
                </TwitterFollowCard>
            </section>
        )

    IMPORTANTE: no es una buena práctica porque puedes enviar información innecesaria y porque puedes provocar que el componente se renderice sin necesidad. Además suele ser menos claro. Solo en determinados casos puede darse por bueno.

40. ESTADO: foto del entorno y sus valores en un momento dado. 

41. HOOK: te permiten añadir cierta funcionalidad a tus componentes. Utilidades de React para dotar de funcionalidad en el renderizado a tus componentes.

42. Añadir un estado a un componente:
    Ej.
        const [isFollowing, setIsFollowing] = useState(initialIsFollowing)    -> donde lo inicializamos con initialIsFollowing
            isFollowing    -> es el estado o nombre de la variable que lo contiene
            setIsFollowing -> es la función que permite modificar ese estado 

    IMPORTANTE: este estado es INTERNO, está a nivel del componente.

43. IMPORTANTE: se llama React por su capacidad de reacción cuando hay un cambio de estado lo refleja en la UI renderizando las partes que hagan falta.

44. DOM Virtual: React solo cambia la parte necesaria para que el renderizado muestre los cambios de estado, lo hace de manera quirúrjica. Para ello React hace una foto de lo que hay renderizado en pantalla (DOM) y cuando se produce
    un cambio de estado busca las diferencias con el nuevo renderizado, este nuevo renderizado se genera en memória en forma de arbol antes de pintarlo (Virtual DOM) y entonces actualiza solo las partes que han cambiado comparando el DOM y el Virtual DOM. 
    REACT renderiza el contenido de forma automática en 2 casos:
        1. Cuando ha cambiado el estado interno de algún componente. 
        2. Cuando un componente padre se vuelve a renderizar y propaga los cambios hacia abajo. Cuando se renderiza un componente se renderizan todos los componentes que hay debajo o implicados en su renderizado.
            Esto pasa por tener estructura de árbol, solo se renderizan los hijos del componente que ha modificado su estado y él mismo, no los padres.        
    CLAVE ==>>  se renderizan de nuevo TODOS los componentes hijo del padre que ha cambiado el estado, aunque no sufran cambios concretos dichos componentes hijo. PERO, cuando React va a renderizar el componente, padre con sus hijos solo
    renderiza o pinta los cambios, por lo que los componentes hijos que no han modificado su html no se pintan de nuevo, aunque se han ejecutado dichos componentes para generar el html de renderizado de nuevo.
    No sobreescribe el DOM, lo deja intacto. Este proceso se hace comparando el DOM con el Virtual DOM y se llama RECONCILIATION.

45. CLAVE ==>> OPTIMIZACIONES: una optimización consiste en evitar que si ciertos componentes hijos no han cambiado nada no se rendericen ni ejecuten sus códigos aunque se modifique el componente padre.

46. De hijos a padres no podemos pasar props, pero podemos pasar callbacks.

47. No hay un hook para manejar el localStorage, pero como es javascript podremos crear nuestros propios hooks para eso y otras cosas.

48. Los comentarios de toda la vida de javascript se pueden incorporar en un componente react:  // comentario,  /* comentarios */
    Pero dentro de la parte de render (return()) del componente tendremos que utilizar { /* comentarios */ }  para que lo interprete, sino lo pondría como renderizado en pantalla.
    No suele ser buena práctica poner comentarios dentro del render.

49. Inicializamos los valores del estado en ocasiones si ya tienen valor previo a la entrada al componente con props, que se llamarán:  initialIsFollowing. 
    Ej.
        export function TwitterFollowCard ({ children, userName, initialIsFollowing }) {
            const [isFollowing, setIsFollowing] = useState(initialIsFollowing)

50. CLAVE ==>> Las props que se usan para inicializar un estado en un componente solo se aplican una vez, luego ya no se vuelven a usar aunque cambiemos su valor. Solo sirven para inicializar el estado la primera vez que renderizamos el componente.
    Por lo que no sirve tener un estado en el componente padre y pasárselo a los hijos como prop de initialIsFollowing pretendiendo que se actualicen los estados de los hijos. 

51. Utilizamos el componente para renderizar una lista de usuarios: como es javascript podemos usar un map de los usuarios y con eso ya lo tendríamos. Envolvemos entre llaves lo que queremos renderizar del componente padre:
    Ej.
        import { TwitterFollowCard } from './TwitterFollowCard.jsx'

        const users = [
        {
            userName: 'midudev',
            name: 'Miguel Ángel Durán',
            isFollowing: true
        },
        {
            userName: 'pheralb',
            name: 'Pablo H.',
            isFollowing: false
        },
        {
            userName: 'PacoHdezs',
            name: 'Paco Hdez',
            isFollowing: true
        },
        {
            userName: 'TMChein',
            name: 'Tomas',
            isFollowing: false
        }
        ]

        export function App () {
        return (
            <section className='App'>
            {
                users.map(({ userName, name, isFollowing }) => (
                <TwitterFollowCard
                    key={userName}
                    userName={userName}
                    initialIsFollowing={isFollowing}
                >
                    {name}
                </TwitterFollowCard>
                ))
            }
            </section>
        )
        }

52. IMPORTANTE: cuando renderizamos una lista o mapeo de elementos debemos indicar la KEY de cada uno de ellos o nos saldrá un warning en el explorador. Esto es porque así react puede identificar 
    cada elemento del array cuando hace sus comparaciones con el DOM Virtual y el DOM. Este valor de la Key es y debe ser único. El index puede usarse como Key si sabemos que cada elemento tiene siempre 
    el mismo índice, si van cambiando pueden darse problemas de rendering. El valor de la Key debe ser algo único de ese elemento.
    OJO: usar key = {Math.random()} no tiene sentido, porque cada vez que se renderice tendremos un valor diferente para el mismo elemento.
    Un Date.now tampoco sirve, ni en general nada aleatorio. Debe ser único para cada elemento. Con el Date.now() podemos tener duplicados y producirse duplicación de elementos renderizados.
    Con el Math.random() puede ser que funcione el render, pero tendremos un problema de rendimiento ya que renderizará todos los elementos.

---------------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------------



Curso de React desde cero: Crea un videojuego y una aplicación para aprender useState y useEffect
https://www.youtube.com/watch?v=qkzcjwnueLA
---------------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------------

53. Si modificas cualquier variable de estado debes hacerlo con su correspondiente función, sino react no sabrá que tiene que renderizar el componente afectado y sus hijos.
    Ej.
        // actualizar el tablero
        const newBoard = [...board]  => hacemos una copia para poder modificar el tablero sin tocar el original
        newBoard[index] = turn       => lo modificamos en la copia
        setBoard(newBoard)           => cambiamos el estado con las modificaciones en el original

54. Para evitar que nos deje modificar un valor ya existente en el tablero:
    Ej.
        // no actualizamos esta posición
        // si ya tiene algo
        if (board[index]) return

55. CAMBIO de ESTADO: el cambio de estado en react es asíncrono, y puede por lo tanto tardar más que el alert.
    Ej.
        // revisar si hay ganador
        const newWinner = checkWinnerFrom(newBoard)
        if (newWinner) {
            setWinner(newWinner)
            alert(`el ganador es ${newWinner}`)  =>  OJO se pintará el alert en pantalla conforme has ganado pero no verás el último movimiento del usuario en pantalla, porque la actualización de los estados es asíncrona
        }

    Por eso usamos los valores a futuro para validaciones de cosas que ya ha hecho el usuario, pero que el estado todavía no regleja.

56. Para poder resetear y volver a empezar de nuevo el juego basta con asegurar de volver a tener los estados como al principio del juego.
    Ej.
        const resetGame = () => {
            setBoard(Array(9).fill(null))
            setTurn(TURNS.X)
            setWinner(null)
        }

57. Para chequear si hemos terminado el juego sin ganador:
    Ej.
        export const checkEndGame = (newBoard) => {
            // revisamos si hay un empate
            // si no hay más espacios vacíos
            // en el tablero
            return newBoard.every((square) => square !== null)    => si no existe ningun null es que hemos completado el tablero
        }

58. Los hooks de useState no deben meterse dentro de un if porque react pierde las posiciones de los mismos y necesita tenerlas. No pueden estar dentro de lógica que cambie su
    posición en el componente, esta debe ser unívoca y clara para react.

59. Guardar el estado de la partida en localStorage:
    Ej.
        export const saveGameToStorage = ({ board, turn }) => {
            // guardar aqui partida
            window.localStorage.setItem('board', JSON.stringify(board))
            window.localStorage.setItem('turn', turn)
        }

60. Recuperar el estado de la partida guardado y si existe inicializar el estado de la misma:
    Ej.
        const [board, setBoard] = useState(() => {
            const boardFromStorage = window.localStorage.getItem('board')
            if (boardFromStorage) return JSON.parse(boardFromStorage)
            return Array(9).fill(null)
        })
    No podemos condicionar como hemos dicho en el punto 58 el hook, pero podemos condicionar el valor que inicializamos.

    CLAVE ==>> la lectura del localStorage es lenta y debemos evitar hacerla si no es necesario. Si la ponemos dentro del useState del board solo se hará en los casos en que se 
    inicialice el tablero, pero si la ponemos justo antes lo hará cada vez que se renderice el componente.

    Lo mismo hacemos con los turnos:
    Ej.
        const [turn, setTurn] = useState(() => {
            const turnFromStorage = window.localStorage.getItem('turn')
            return turnFromStorage ?? TURNS.X
        })

61. Hay que acordarse de resetear los valores del localStorage cuando reseteamos el juego:
    Ej.
        const resetGame = () => {
            setBoard(Array(9).fill(null))
            setTurn(TURNS.X)
            setWinner(null)

            resetGameStorage()
        }

62. useEffect: es un hook que nos permite ejecutar código arbitrario cuando el componente se monta en el DOM y cada vez que cambian las dependencias que nosotros le indicamos
    Ej.
        useEffect(() => {
            document.body.classList.toggle('no-cursor', enabled)

            return () => {
            document.body.classList.remove('no-cursor')
            }
        }, [enabled])

    Tiene como parámetros una función y luego una lista opcional de valores sobre los que ejercerá el control y en caso de cambiar ejecutará la función. También ejecutará la función al 
    montar el componente donde esté.

    Si la lista de valores no está informada la función se ejecutará cada vez que se renderice el componente.

    Si la lista de valores está vacía [] se ejecutará solo la primera vez que se renderice el componente.

    Cuando informamos valores en la lista es como suscribirse a un evento. Se ejecutará siempre que pase.

    CLAVE ==>> usamos el useEffect para cargar listeners o apis de terceros que no tiene sentido que se ejecuten cada vez que se renderice el componente, así lo ejecutaremos cuando queramos.

    No permiten parámetros las funciones useEffect.

63. CLAVE ==>> Requisitos para instalar en los proyectos:
    1. npm install standard -D      => son reglas de linter 
    2. En el package.json aparcerá el standard recien instalado, y añadiremos lo siguiente:
        Ej. 
            "devDependencies": {
                "standard": "17.0.0"
            },
            "eslintConfig": {
                "extends": "./node_modules/standard/eslintrc.json"
            }
    3. Instalamos la extensión de eslint en el visual studio code
    Ahora cuando abrimos una página nos salen advertencias de posibles errores de sintaxis, espacios, comillas, lineas, ... Al guardar si tenemos activado el corrector automático o editor automático nos lo 
    corregirá automáticamente.

64. Proyecto para que una animación siga al puntero por la pantalla:
    Ej. 
        // pointer move
        useEffect(() => {
            console.log('effect ', { enabled })

            const handleMove = (event) => {
            const { clientX, clientY } = event
            setPosition({ x: clientX, y: clientY })
            }

            if (enabled) {                                          => importante, solo añadimos el listener si esta activo el enabled
                window.addEventListener('pointermove', handleMove)
            }

            // cleanup:
            // -> cuando el componente se desmonta
            // -> cuando cambian las dependencias, antes de ejecutar
            //    el efecto de nuevo
            return () => { // cleanup method
                console.log('cleanup')
                window.removeEventListener('pointermove', handleMove)           => CLAVE ==>> CLEAN useEffect: las suscripciones las tenemos que limpiar, 
            }                                                                                 porque persisten en el tiempo, react no las cancela
        }, [enabled])

    CLAVE ==>> no podemos meter el useEffect en el condicional  if(enabled)   ni en ningún otro por lo que habíamos dicho de la posición de los hook en react.

    Es buena práctica inicializar con valores siempre que podamos, sino con null.
    Ej.
        const [position, setPosition] = useState({ x: 0, y: 0 })

    
65. CLAVE ==>> CLEAN useEffect: las suscripciones las tenemos que limpiar, porque persisten en el tiempo, react no las cancela. ¿Cuando hacer esas limpiezas? pues en el return() 
    que podemos indicar para las funciones useEffect. Podemos declarar una función que haga estas limpiezas.
    Ej.
        return () => { // cleanup method
            console.log('cleanup')
            window.removeEventListener('pointermove', handleMove)           
        }        

    ¿Cuando se ejecuta este return? 
        1. Siempre que se desmonte el componente
        2. Cada vez que cambien las dependencias de la función useEffect -> se ejecuta antes del propio useEffect, realiza una limpieza previa antes del nuevo efecto.

66. CLAVE ==>> Si no limpiamos las suscripciones en las funciones useEffect no solo tendremos un problema de funcionamiento, sino que se irán creando nuevas suscripciones ocupando 
    recursos y penalizando el rendimiento del app.

67. CLAVE ==>> Si queremos saber cuantas suscripciones se han realizado a un determinado evento en el chrome podemos ir a Consola y poner: getEventListeners(window)
    Nos indicará un array con las suscripciones a cada evento en caso de existir más de una. Con esto podremos ver si estamos limpiando bien los eventos. También sirve para
    determinar problemas de rendimiento en páginas web.

68. React.StrictMode: se utiliza para que te de avisos si estás haciendo algo incorrecto, si estás utilizando react antiguo, y tiene una particularidad al montar los componentes: 
    ejecuta el efecto del componente, ejecuta el cleanup del mismo componente y luego vuelve a ejecutar el efecto del componente. Esto solo pasa en desarrollo, y ejecuta entonces
    2 veces los componentes. Es una ayuda para detectar malos funcionamientos en desarrollo. El React.StrictMode en producción lo ignora y es como si no existiera. En desarrollo 
    si quisieramos podemos quitarlo y dejará de hacer el doble ejecutor.

69. CLAVE ==>> React Developer Tools: son unas herramientas de desarrollo para cualquier explorador de windows de los más conocidos.
    Una vez instalada nos indicará en un inconito superior derecho si estamos en desarrollo o producción, el primer caso aparece en rojo con un escarabajo de debug.
    Si miramos al final hay 2 nuevas opciones: 
        1. Profiler:
            Ejecutamos nuestra aplicación después de darle a grabar en Profiler y luego miramos en profiler, podremos ver temas de rendimiento. Le tenemos que dar a grabar y despues de parar 
            la grabación podremos estudiar el comportamiento de nuestra app web. Indicando las renderizaciones y qué las ha causado. 
        2. Components:
            Los nombres de los componentes en producción normalmente están minificados, salvo que hubieran puesto el DisplayName.
            Pero en desarrollo lo veremos todo, y no solo los componentes, podremos ver sus props y estados y podremos cambiar sus valores. Veremos los hooks. Y como en html al hacer click sobre un
            componente lo seleccionarán en la pantalla del la web. Esto nos permite ver si modificamos el estado como responde nuestra UI.
            Es super potente porque te permite replicar situaciones en los cambios de estado por ejemplo que nos permetirá reproducir errores o momentos del web.
            Otra cosa interesante es que muestra el arbol de componentes completo del web. Los valores solo los permite cambiar en desarrollo.

70. Montar un useEffect para quitar / ocultar el mouse en pantalla:
    Ej.
        // change body className
        useEffect(() => {
            document.body.classList.toggle('no-cursor', enabled)

            return () => {
            document.body.classList.remove('no-cursor')
            }
        }, [enabled])

71. No es una buena práctica usar un solo useEffect para hacerlo todo, es mejor tener varios cada uno con su objetivo.

72. Dentro de Netlify tenemos app.netlify.com/drop que nos permite mediante arrastre de la carpeta dist creada por el npm run build. Si no nos registramos lo mantiene por 1 hora.


---------------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------------


Prueba Técnica de React para Juniors y Trainee
https://www.youtube.com/watch?v=XYpadB4VadY
---------------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------------

Vamos a hacer la prueba sin tener plantilla inicial de React, es decir creando un proyecto con Vite pero con Vanilla y luego lo transformamos a React.

73. creamos el proyecto Vanilla:
    Ej.
        npm create vite@latest
            react-prueba-tecnica
            Vanilla
            JavaScript

        cd react-prueba-tecnica

74. Instalamos un plugin de react
    Ej.
        npm install @vitejs/plugin-react -E
        code .

75. Tenemos la plantilla pero si abrimos el package.json vemos que no tenemos react ni sus dependencias. Las instalamos:
    Ej.
        npm install react react-dom -E
            donde react es la biblioteca de react que tiene los hooks y demás
            y react-dom es la que tiene los bindings con el navegador

76. Creamos el fichero vite.config.js o lo rellenamos con:
    Ej.
        import { defineConfig } from 'vite'
        import react from '@vitejs/plugin-react'

        export default defineConfig({
            plugins: [react()]
        })

77. CLAVE ==>> Creamos el punto de entrada de la aplicación de react (es crear el elemento raiz de la misma y poner el primer componente):
    Esto lo hacemos en nuestro main.js puesto que es el primer archivo que se carga a través de nuestro index.html
    Ej.
        import { createRoot } from 'react-dom/client'

        const root = createRoot(document.getElementById('app'))
        root.render(<h1>Hello, world!</h1>)    

    CLAVE ==>> Problema: este código no se ejecuta porque requiere la extensión .jsx para hacerlo transpilando el código con SWC o similar. Renombramos a main.jsx.
    También modificamos la referencia en index.html al nuevo archivo main.jsx

78. Instalamos el eslint:
    Ej.
        npm install standard -D

    Lo configuramos en el package.json añadiendo:
    Ej.
        ,
        "eslintConfig": {
            "extends": "./node_modules/standard/eslintrc.json"
        }

79. Creamos el Readme.md y añadimos la descripción de la prueba técnica:
    Ej.
        # Prueba técnica para Juniors y Trainees de React en Live Coding.

        APIs:

        - Facts Random: https://catfact.ninja/fact
        - Imagen random: https://cataas.com/cat/says/hello

        - Recupera un hecho aleatorio de gatos de la primera API y muestra una imagen de un gato con la primera palabra del hecho recuperado usando la segunda API.

80. Creamos el App.jsx dentro de mi src/Components
    Ej.
        export function App () {
            return (
                <h1>App de gatitos</h1>   
        )}

    Importamos el componente en nuestro main.jsx y lo llamamos en el cuerpo:
    Ej.
        import { createRoot } from 'react-dom/client'
        import { App } from './src/App.jsx'

        const root = createRoot(document.getElementById('app'))
        root.render(<App />)

81. CLAVE ==>> conforme vamos programando debemos ir mostrando cosas en la pantalla que demuestren nuestro progreso.

82. Definir la prueba en subtareas a realizar:
    - Recupera un hecho aleatorio de gatos de la primera API
    - Recuperar la primera palabra del hecho
    - Muestra una imagen de un gato con la primera palabra del hecho recuperado usando la segunda API.

    CLAVE ==>> concretar lo que devuelve la API y asegurar el endpoint que vamos a utilizar. Incluso lo pondríamos en una constante dentro de un template ya con las partes a cambiar:
        Ej.
            const CAT_ENDPOINT_RANDOM_FACT = 'https://catfact.ninja/fact'

83. Recuperamos el useState y creamos un estado fact:
    Ej.
        import {useState} from "react"

        export function App () {
            const {fact, setFact} = useState('lorem ipsum what the fact')

            CLAVE ==>> no podemos poner aquí un fetch de datos porque esto se ejecuta cada vez que renderizamos nuestro componente

            CLAVE ==>> Usamos un useEffect para que la primera vez que se va a montar nuestro componente haga el fecth

            CLAVE ==>> No olvidarse de poner la dependencia: []  o entraremos en bucle infinito y tendremos problemas 

            useEffect (() => {
                fetch('https://catfact.ninja/fact')
                    .then(res => res.json())
                    .then(data => setFact(data.fact))
            }, [])

            return (
                <main>
                    <h1>App de gatitos</h1>
                    {fact && <p>{fact}</p>}         // Usamos el renderizado condicional como algo que ya sabemos hacer
                </main>
        )}

    Un fetch devuelve una promesa que todavía no la tenemos en json, por lo que lo hacemos y después cambiamos el estado con los datos 
    
84. En useEffect si queremos poner async await debemos envolverlo:
    Ej.
        useEffect (() => {
            async function getRandomFact () {                
                const res = await fetch('https://catfact.ninja/fact')
                const json = await res.json()
                setFact(json.fact)                
            }

            getRandomFact()            
        }, [])

    CLAVE ==>> No podemos poner el async await directamente en el useEffect.

85. Justo despues de obtener el fact buscamos la primera palabra del mismo:
    Ej.
        const firstWord = fact.split(' ')[0]

    IMPORTANTE: si quieren que nos quedemos con las 3 primeras palabras:
        Ej.
            const firstWord = fact.split(' ').slice(0, 3).join(' ')
            el split obtiene un array con tantas palabras como tengamos.
            el slice obtiene las 3 primeras
            el join las une con espacios en una cadena de texto

    Una opción más óptima de este último caso es:
        Ej.
            const firstWord = fact.split(' ', 3).join(' ')

86. CLAVE ==>> para buscar cosas del lenguaje como la función para separar string por un token: 
    Ej. 
        en el buscador de google ponemos: mdn separar string por separador

87. CLAVE ==>> NO busquéis la solución a lo que os piden en google, buscar documentación de lo que necesitáis para resolverlo, pero no de ejemplos ya hechos.    

88. usamos la segunda API con nuestra primera palabra. Para guardarla necesitamos otro estado:
    Ej.
        onst [imageUrl, setImageUrl] = useState()

        useEffect (() => {
            fetch(`https://cataas.com/cat/says/${threeFirstWords}?size=50&color=red&json=true`)
                .then(res => res.json())
                .then(data => {
                    const {url} = data
                    setImageUrl(`https://cataas.com${url}`)       // esto funcionaría pero se puede hacer mejor -> punto 18
            })
        }, [])

89. Presentamos los datos obtenidos:
    Ej.
         return (
                <main>
                    <h1>App de gatitos</h1>
                    {fact && <p>{fact}</p>}         // Usamos el renderizado condicional como algo que ya sabemos hacer
                    {imageUrl && <img src={imageUrl} alt='Imágen extraida de la segunda API con 3 palabras de la primera API.' />}
                </main>
         )

    Poner el contenido del alt con un texto coherente que explique lo que hace la imagen

90. Razones por las que no poner en el estado la parte raiz de la url:
    Porque en el estado tenemos que tener lo mínimo posible, y esto lo podemos tener fuera.

91. Si os piden alinear al centro los componentes en pantalla:
    Dais estilos:
        En columna:  
        Ej.
            main {
                display: flex;
                flex-direction: column;
                place-items: center;           es lo mismo que poner justify-content: center; y align-items: center; juntos
                max-width: 800px;
                margin: 0 auto;
                font-family: system-ui;
            }
    
        Si lo queremos en fila: 

        Añadimos un section:
        Ej.
            return (
                <main>
                    <h1>App de gatitos</h1>
                    <section>
                        {fact && <p>{fact}</p>}         // Usamos el renderizado condicional como algo que ya sabemos hacer
                        {imageUrl && <img src={imageUrl} alt='Imágen extraida de la segunda API con 3 palabras de la primera API.' />}
                    </section>                    
                </main>
            )

        cambiamos los estilos:
        Ej.
            section {
                display: flex;
                justify-content: space-between;
                align-items: center;
                gap: 2rem;   
            }

            section img {
                max-width: 320px;
                height: auto;
            }

92. CLAVE ==>> los efectos en react debería tener una sola responsabilidad, si les damos varias no es una buena práctica.
    Esto distribuye las responsabilidades y evita la anidación.
    Ej.
        useEffect (() => {
            async function getRandomFact () {                
                const res = await fetch('https://catfact.ninja/fact')
                const json = await res.json()
                setFact(json.fact)                
            }

            getRandomFact()            
        }, [])

        useEffect (() => {
            if (!fact) return
            fetch(`https://cataas.com/cat/says/${threeFirstWords}?size=50&color=red&json=true`)
                .then(res => res.json())
                .then(data => {
                    const {url} = data
                    setImageUrl(`https://cataas.com${url}`)       // esto funcionaría pero se puede hacer mejor -> punto 18
            })
        }, [fact])

93. CLAVE ==>> los errores se pueden gestionar en el useEffect, pero hay que tener en cuenta que entraremos en el catch si hay errores con la petición, no con la
    respuesta. Esta la tenemos que controlar nosotros.
    Ej.
            useEffect (() => {
                fetch('https://catfact.ninja/fact')
                    .then(res => {
                        if (!res.ok) throw new Error('Error fetching fact')    // asi llegaremos al catch también si hay un error con la petición
                        return res.json()                        
                    )
                    .then(data => setFact(data.fact))
                    .catch((err) => {
                        // solo errores en la petición
                    })
            }, [])

94. Normalmente nos pedirán añadir un botón que al darle refresquemos la imagen o hagamos alguna acción sobre el componente:
    Ej.
        async function getRandomFact () {                
            const res = await fetch('https://catfact.ninja/fact')
            const data = await res.json()
            const { fact } = data
            return fact
        }

        CLAVE ==>> si separamos la lógica en funciones para poder reutilizarlas no es buena práctica pasar estados o funciones de modificación de estados de nuestro 
        componente a la función. Tiene que ser completamente reutilizable, lo que es react que se quede en el componente. Así si que podemos crearla en un archivo .js
        y luego importarla.

        useEffect (() => {
            getRandomFact().then(setFact)               CLAVE ==>> sería lo mismo que escribir: getRandomFact().then(newfact => setFact(newfact))     
        }, [])

        const handleClick = async () => {
            const newfact = await getRandomFact()
            setFact(newfact)            
        }

        <button onclick={handleClick}>Get new fact</button>

---------------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------------




Custom Hooks + Testing con Playwright: Curso de React desde cero - Parte 4
https://www.youtube.com/watch?v=x-LcbVw99o8
---------------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------------

95. CLAVE ==>> Un Custom Hook es simplemente extraer lógica de nuestros componentes para poder reutilizarla en otros componentes

96. Creación de un Custom Hook -> debemos crear una función que empiece con la palabra useXXXXXXXX seguida del resto del nombre 
    Ej.
        function useCatImage () {}

97. Uso del Custom Hook: 
    Ej.
        const prefijo = useCatImage()

98. En nuestro caso es más complejo, para tener la lógica que recupera la imagen del gato creamos un fichero useCatImage.js. No requieren de un .jsx porque no tienen. 
    Movemos dentro de la función la lógica de nuestro componente de react que ya estaba funcionando tal cual, con estado incluído:
    Ej.
        import { useEffect, useState } from 'react'

        const CAT_PREFIX_IMAGE_URL = 'https://cataas.com'

        export function useCatImage ({ fact }) {                                // los parámetros van entre llaves en este caso por buenas prácticas ver punto 101
            const [imageUrl, setImageUrl] = useState()

            // para recuperar la imagen cada vez que tenemos una cita nueva
            useEffect(() => {
                if (!fact) return

                const threeFirstWords = fact.split(' ', 3).join(' ')

                fetch(`https://cataas.com/cat/says/${threeFirstWords}?size=50&color=red&json=true`)
                .then(res => res.json())
                .then(response => {
                    const { _id } = response
                    const url = `/cat/${_id}/says/${threeFirstWords}`
                    setImageUrl(url)
                })
            }, [fact])

            return { imageUrl: `${CAT_PREFIX_IMAGE_URL}${imageUrl}` }
        }

99. Uso de nuestro custom hook:
    En el componente que lo va a utilizar ya podemos llamarlo y obtener la imagen:  
    Ej.
        const { imageUrl } = useCatImage({ fact })

    CLAVE ==>> Esta llamada no la podemos poner dentro de un if, ni un while ni en ninguno de los casos en que no se permite un hook, igual que cualquier hook de react.

100. CLAVE ==>> La diferencia entre un Custom Hook y una función normal radica en que en un Custom Hook se pueden usar hooks de react y en una función normal NO.

101. Pasando los parámetros entre llaves los estamos pasando como un objeto, con esto favorecemos la extensibilidad de nuestra función. Si en el futuro añadimos nuevos parámetros a la
    función simplemente los añadimos al objeto separándolos por comas, y el orden es indiferente en el paso del parámetro. Además el nombre de cada elemento del objeto tiene que ser el que
    hemos requerido en nuestra función mientras que en un parámetro normal podemos poner el nombre que queramos al parámetro que pasamos. Ganamos claridad, y facilidad de extensibilidad 
    haciéndolo con un objeto.

102. IMPORTANTE: evitar darle un nombre al custom hook que te diga en que está basada la implementación, ej. useFetchCat.  Tienen que ser una caja negra independiente de la implementación.

103. Hacemos otro custom hook en nuestro proyecto para recuperar la cita en la página. Creamos el fichero useCatFact.js y ponemos:
    Ej.
        import { useState, useEffect } from 'react'
        import { getRandomFact } from '../services/facts.js'

        export function useCatFact () {
            const [fact, setFact] = useState()          // su estado interno

            const refreshFact = () => {
                getRandomFact().then(newFact => setFact(newFact))       // llama a la función que hace el fetch a nuestra API y luego asigna el estado con el resultado
            }

            // para recuperar la cita al cargar la página
            useEffect(refreshFact, [])                      // ejecuta la función refreshFact cada vez que se monta el componente

            return { fact, refreshFact }    CLAVE ==>> como en el botón del App.jsx tenemos que hacer lo mismo que hace refreshFact la devolvemos también.
        }

    Donde la función getRandomFact estaría definida en el fichero fact.js como:
    Ej.
        const CAT_ENDPOINT_RANDOM_FACT = 'https://catfact.ninja/fact'

        export const getRandomFact = async () => {
            const res = await fetch(CAT_ENDPOINT_RANDOM_FACT)
            const data = await res.json()
            const { fact } = data
            return fact
        }

    Para usarlo en nuestro App.jsx ponemos:
    Ej.
        import './App.css'
        import { useCatImage } from './hooks/useCatImage.js'
        import { useCatFact } from './hooks/useCatFact.js'

        export function App () {
        const { fact, refreshFact } = useCatFact()
        const { imageUrl } = useCatImage({ fact })      // IMPORTANTE: esta línea no puede ir delante de la que utiliza useCatFact para definir nuestro fact

        const handleClick = async () => {
            refreshFact()                   // IMPORTANTE: hemos reutilizado una llamada a una función interna a nuestro hook que actualiza o modifica el estado interno del mismo sin exportar el propio setFact,
                                                            es mejor que lo haga el custom hook internamente
        }

        return (
            <main>
            <h1>App de gatitos</h1>

            <button onClick={handleClick}>Get new fact</button>

            {fact && <p>{fact}</p>}
            {imageUrl && <img src={imageUrl} alt={`Image extracted using the first three words for ${fact}`} />}
            </main>
        )
        }  

104. CLAVE ==>> siempre que veamos un useEffect y otros casos hay que preguntarse si no valdría la pena tenerlo en un custom hook. Porque sería lógica reutilizable que tendríamos fuera de nuestro componente.

105. CLAVE ==>> si nos dicen que más haríamos si tenemos tiempo: 
        1. Control de errores en nuestros componentes.
        2. Testing del app.

106. Test básico: 
    Instalamos un testeador: npm init Playwright@latest
        Indicamos JavaScript
        carpeta tests
        NO al añadir Github actions
        SI a Instalar Playwright browser

    Nos habrá creado un ejemplo en la carpeta tests. Lo modificamos con nuestro test:
    Ej.
        // @ts-check
        import { test, expect } from '@playwright/test'       // OJO: si al ejecutar da error puede ser que estemos utilizando EMACS y no admita los Required del playwright, habrá que modifcarlos por imports como en este caso.

        const CAT_PREFIX_IMAGE_URL = 'https://cataas.com'
        const LOCALHOST_URL = 'http://localhost:5173/'

        test('app shows random fact and image', async ({ page }) => {
        await page.goto(LOCALHOST_URL)

        const text = await page.getByRole('paragraph')     // recuperamos un párrafo de nuestra página, pilla el primero
        const image = await page.getByRole('img')          // recuperamos una primera imagen, como solo gat una ya nos vale 

        const textContent = await text.textContent()
        const imageSrc = await image.getAttribute('src')

        await expect(textContent?.length).toBeGreaterThan(0)                            // exige que tengamos un texto con contenido
        await expect(imageSrc?.startsWith(CAT_PREFIX_IMAGE_URL)).toBeTruthy()           // exige que tengamos una imagen válida de alguna forma
        })

    Ejecutamos el test:
    Ej.
        npx playwright test
        ... 1 passed (1.4s)

    

---------------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------------




Aprende a pasar una Prueba Técnica de React. Entiende useMemo, useCallback y useRef
https://www.youtube.com/watch?v=GOEiMwDJ3lc
---------------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------------

Prueba: Crea una aplicación para buscar películas

API a usar: - https://www.omdbapi.com/
Consigue la API Key en la propia página web registrando tu email.

Requerimientos:

✅ Necesita mostrar un input para buscar la película y un botón para buscar.

✅ Lista las películas y muestra el título, año y poster.

✅ Que el formulario funcione

✅ Haz que las películas se muestren en un grid responsive.

✅ Hacer el fetching de datos a la API

Primera iteración:

✅ Evitar que se haga la misma búsqueda dos veces seguidas.

✅ Haz que la búsqueda se haga automáticamente al escribir.

✅ Evita que se haga la búsqueda continuamente al escribir (debounce)


RESULTADO:

107. Creamos el proyecto con VITE: 
    Ej.
        npm create vite@latest
        cd 05-react-buscador-peliculas
        npm install
        code .
    
108. En el placeholder de un input no se pone un mensaje: escribe aquí tu película...  es más correcto poner un ejemplo de lo que pondrías: ej. Avengers, Matrix, ...
    
109. Ir a la API y mirar si hay una api que nos permita buscar. Probarla y mirar el resultado. Conesto sabremos lo que vamos a tener que tratar. No usar Console.log para ver el resultado,
    ni empezar a desarrollar sin haber visto lo que devuelve y requiere la llamada a la API.

    Probar también a buscar algo que no existe y ver que devuelve. 
    Crear mocks de estas respuestas para tenerlas en nuestro proyecto sin necesidad de API.
    Dentro del directorio mocks creamos: no-results.json y with-results.json.

110. Ya podemos mostrar y trabajar en los datos de la web sin tener el fetch, simplemente importando los mocks:
    Ej.
        import withResults from '.mocks/with-results.json'
        import withoutResults from '.mocks/no-results.json'
    
    Ahora podemos acceder a los objetos json y podremos ver los campos / tipos de que constan, asi como comprobar si tenemos datos y hacer un renderizado condicional.

111. Es una mala práctica hacer esto:
    Ej.
        const renderMovies = () => {
            return (
                <ul>
                    {
                        movies.map( movie => (
                            <li key={movie.imdbID}>
                                <h3>{movie.Tittle}</h3>
                                <p>{movie.Year}</p>
                                <img src={movie.Poster} alt={movie.Title} />
                            </li>
                        ))
                    }
                </ul>
            )
        }

        <main>
            {
                hasMovies 
                    ? renderMovies()
                    : renderNoResults()
            }
        </main>

    La razón es porque ese renderizado debería ser un componente react!

112. Creamos un componente de Movies:
    Ej.
        function ListOfMovies ({ movies }) {
            return (
                <ul className='movies'>
                {
                    movies.map(movie => (
                    <li key={movie.imdbID}>
                        <h3>{movie.Title}</h3>
                        <p>{movie.Year}</p>
                        <img src={movie.Poster} alt={movie.title} />
                    </li>
                    ))
                }
                </ul>
            )
        }

        function NoMoviesResults () {
            return (
                <p>No se encontraron películas para esta búsqueda</p>
            )
        }

        export function Movies ({ movies }) {
            const hasMovies = movies?.length > 0

            return (
                hasMovies
                ? <ListOfMovies movies={movies} />
                : <NoMoviesResults />
            )
        }

113. OJO, no es una buena práctica utiliza los atributos tal cual están en la API, quedamos muy expuestos a cambios del API, es mejor usar un mapped:
    Ej.
        const mappedMovies = movies?.map(movie => ({
            id: movie.imdbID,
            title: movie.Title,
            year: movie.Year,
            poster: movie.Poster
        }))

    De esta forma si cambia la firma de la API solo tendremos que tocar en este sitio para adaptarlo.

    Modificamos la función: 
    Ej.
        function ListOfMovies ({ movies }) {
            return (
                <ul className='movies'>
                {
                    movies.map(movie => (
                    <li key={movie.id}>
                        <h3>{movie.title}</h3>
                        <p>{movie.year}</p>
                        <img src={movie.poster} alt={movie.title} />
                    </li>
                    ))
                }
                </ul>
            )
        }

114. Creamos un Custom Hook para todo lo de los movies:
    Ej.
        import { useRef, useState } from 'react'
        import { searchMovies } from '../services/movies.js'

        export function useMovies () {
            const movies = responseMovies.Search

            const mappedMovies = movies?.map(movie => ({
                id: movie.imdbID,
                title: movie.Title,
                year: movie.Year,
                poster: movie.Poster
            }))
        
        return { movies: mappedMovies }
        }

        function App () {
            const {movies} = useMovies()

            return (
                ...
                <main>
                    <Movies movies={movies} />
                </main>        
            )
        }

115. CLAVE ==>> Nuevo Hook useRef: te permite crear una referencia a un elemento del DOM, esta sería una explicación mala. En realidad es un hook que te permite crear una
    referencia mutable que persiste durante todo el ciclo de vida de tu componente. Puedes guardar un contador y cada vez que cambie no vuelve a renderizar el componente como
    con el useState. El useState cada vez que cambia renderiza el componente, pero en cambio el useRef no renderiza el componente al cambiar el valor.
    Por esto es útil para guardar una referencia a un elemento del DOM y siempre lo tendremos accesible.
    Ej.
        const inputRef = useRef()

        const handleClick = () => {
            const inputEl = inputRef.current
            const value = inputEl.value
            console.log(value)
        }

        return (
            <div className='page'>
                <header>
                    <h1>Buscador de películas</h1>
                    <form className='form'>
                        <input
                            ref={inputRef}
                            placeholder='Avengers, Star Wars, The Matrix...'
                        />
                        <button onclick={handleClick} type='submit'>Buscar</button>
                    </form>
                </header>

                <main>
                    <Movies movies={movies} />                
                </main>
            </div>
        )

    Por ejemplo si en un componente ponemos:
    Ej.
        const current = useRef(0)       => es un valor que persiste entre renders
        counter.current++
        console.log(counter.current)

    En este caso veríamos que al renderizarse el componente se aumentaría el valor escrito, sería un contador de renderizados. A pesar de la inicialización a 0.
    Por ejemplo con una variable normal no pasaría:
        let i = 0
        i++ 
        console.log(i)      => siempre que se renderice pintará 1

116. No es una buena práctica aunque funciona hacer un handleClick de un botón tipo submit, es mejor hacer una handleSubmit asociado a ese botón.
    Ej.
        const inputRef = useRef()

        const handleSubmit = (event) => {
            event.preventDefault
            const inputEl = inputRef.current
            const value = inputEl.value
            console.log(value)
        }

        return (
            <div className='page'>
                <header>
                    <h1>Buscador de películas</h1>
                    <form className='form' onSubmit={handleSubmit}>
                        <input
                            ref={inputRef}
                            placeholder='Avengers, Star Wars, The Matrix...'
                        />
                        <button type='submit'>Buscar</button>
                    </form>
                </header>

                <main>
                    <Movies movies={movies} />                
                </main>
            </div>
        )

117. CLAVE ==>> Aunque no está mal hecho, es mejor práctica usar javascript de toda la vida para hacer lo mismo con FormData sobre el evento:
    Ej.
        const handleSubmit = (event) => {
            event.preventDefault
            const data = new window.FormData(event.target)   
            const query = data.get('query')         
            // aquí validamos los datos introducidos
            console.log(query)
        }

    Si hay muchos inputs podemos recuperarlos todos:
    Ej.
        const handleSubmit = (event) => {
            event.preventDefault
            const data = Object.fromEntries(new window.FormData(event.target))
            console.log(data)            
        }

        return (
            <div className='page'>
                <header>
                    <h1>Buscador de películas</h1>
                    <form className='form' onSubmit={handleSubmit}>
                        <input name='query'
                            placeholder='Avengers, Star Wars, The Matrix...'
                        />
                        <input
                            name='otro'
                            placeholder='Avengers, Star Wars, The Matrix...'
                        />
                        <input
                            name='otro2'
                            placeholder='Avengers, Star Wars, The Matrix...'
                        />
                        <button type='submit'>Buscar</button>
                    </form>
                </header>

                <main>
                    <Movies movies={movies} />                
                </main>
            </div>
        )

    No user el useRef para tener la referencia de muchos campos, es mejor hacerlo con javascript usando FormData 
    Ej.
        const { query } = Object.fromEntries(new window.FormData(event.target))   => como en el ejemplo anterior pero sabiendo que tenemos un objeto con el name query
    Esta es la primera de las 2 forma de gestionar un formulario, es la NO CONTROLADA POR REACT. Mediante el DOM, con un submit y demás. Es la forma más eficiente y rápida.
    En la forma NO CONTROLADA POR REACT también encontramos el required, pattern = '' en el Input de javascript, el onInvalid en el onSubmit, ...

118. SEGUNDA forma de gestionar un Form: CONTROLADA POR REACT:
    Vamos a crear un estado que controla los datos que escribimos en los inputs.
    Ej.
        const [query, setQuery] = useState('')
        const [error, setError] = useState(null)

        const handleChange = (event) => {
            setQuery(event.target.value)        => actualiza el estado con el nuevo valor que ha introducido el usuario
            
            // VALIDACIONES OPCION A
            // ojo no validar sobre el valor del estado query porque no garantizamos que se halla asignado al ser asíncrono
            // para ello asignamos el value del evento y validamos sobre el
            const newQuery = event.target.value
            if (newQuery == '') {
                setError('No se puede buscar una película vacía!')
                return
            }

            if (newQuery.match(/^\d+$/)) {
                setError('No se puede buscar una película con un número!')
                return
            }

            if (newQuery.length < 3) {
                setError('La búsqueda debe tener al menos 3 caracteres!')
                return
            }

            setError(null)
        }

        const handleSubmit = (event) => {
            event.preventDefault
            console.log({ query })              => ya tenemos el valor del input del usuario en el estado        
        }

        return (
            <div className='page'>
                <header>
                    <h1>Buscador de películas</h1>
                    <form className='form' onSubmit={handleSubmit}>
                        <input onChange={handleChange} name='query'
                            placeholder='Avengers, Star Wars, The Matrix...'
                        />
                        <input
                            name='otro'
                            placeholder='Avengers, Star Wars, The Matrix...'
                        />
                        <input
                            name='otro2'
                            placeholder='Avengers, Star Wars, The Matrix...'
                        />
                        <button type='submit'>Buscar</button>
                    </form>
                    {error && <p className='error'>{error}</p>}
                </header>

                <main>
                    <Movies movies={movies} />                
                </main>
            </div>
        )

    Esta forma CONTROLADA POR REACT tiene el inconveniente de que al cambiar el estado de valor fuerza la renderización de la pantalla o componente. Como ventaja tener el código más
    ordenado y no preocuparte del DOM para las validaciones que se pueden hacer de muchas maneras. Hay un hook que ayuda a paliar esta pérdida de eficiencia.
    Otra ventaja es que puedes hacer pre-validaciones en la forma Controlada de forma fácil mientras que en la forma controlada necesitarías mucho javascript para hacerlo.
    Ej.
        const handleChange = (event) => {
            const newQuery = event.target.value
            if (newQuery.startsWith(' ')) return    => si intentamos empezar con espacio no nos lo dejará hacer
            setQuery(newQuery)  
        }  
    En este caso evitamos que el estado se actualice y por lo tanto no se renderiza el componente.          

    De todas formas la forma NO CONTROLADA POR REACT es mucha más eficiente y podría ser la recomendada. 

    En la forma controlada puedes hacer las validaciones en el handleChange: VALIDACIONES OPCION A
    También podríamos usar un useEffect:
    Ej.
        useEffect ( () => {
            // VALIDACIONES OPCION B
            if (query == '') {
                setError('No se puede buscar una película vacía!')
                return
            }

            if (query.match(/^\d+$/)) {
                setError('No se puede buscar una película con un número!')
                return
            }

            if (query.length < 3) {
                setError('La búsqueda debe tener al menos 3 caracteres!')
                return
            }

            setError(null)
        }, [search])

    (se recomienda el uso de ZOT para este tipo de validaciones)

119. Lo mejor como siempre es dejar limpios nuestros componentes de lógica sacando toda como custom hook. 
    Ej.
        function useSearch () {
            const [search, updateSearch] = useState('')
            const [error, setError] = useState(null)
            const isFirstInput = useRef(true)           => uso del useRef como banderita para saber si es la primera vez que validamos o no 

            useEffect(() => {
                if (isFirstInput.current) {
                    isFirstInput.current = search === ''        => en cuanto el usuario teclee algo en el input dejará de ser cierto el useRef banderita
                    return
                }

                if (search === '') {
                setError('No se puede buscar una película vacía')
                return
                }

                if (search.match(/^\d+$/)) {
                setError('No se puede buscar una película con un número')
                return
                }

                if (search.length < 3) {
                setError('La búsqueda debe tener al menos 3 caracteres')
                return
                }

                setError(null)
            }, [search])

            return { search, updateSearch, error }
            }

            function App () {
            const [sort, setSort] = useState(false)
            const { search, updateSearch, error } = useSearch()

120. CLAVE ==>> otro uso del useRef consiste en evitar validaciones iniciales que se basan en los estados iniciales y no en las entradas del usuario.
    Ej.
        useEffect(() => {
            if (search === '') {
                setError('No se puede buscar una película vacía')
                return
            }   
        })     
    Este useEffect dará el mensaje de error de 'No se puede buscar una película vacía' nada más entrar porqué validará el contenido inicial vacío del estado de search.
    Para evitar esto se usa el useRef a modo de banderita como en el ejemplo anterior: const isFirstInput = useRef(true) 
    El valor lo chequeamos al principio del useEffect y en caso de ser cierto no hacemos nada, pero chequeamos si el usuario ha entrado algo en el input y cambiamos su valor
    a false en caso afirmativo. La ventaja es que el useRef no renderiza el componente de nuevo al cambiar el valor.

121. Sabemos que debemos usar un custom hook y no un helper típico de javascript cuando por un lado hay un useEffect en nuestro código a extraer. En general si hay algún hook
    en nuestro código lo mejor es usar un custom hook, sino usamos un helper de JS.

122. CLAVE ==>> GRID RESPONSIVE
    Ej.
        function ListOfMovies ({ movies }) {
            return (
                <ul className='movies'>
                {
                    movies.map(movie => (
                    <li className='movie'
                        key={movie.id}>
                        <h3>{movie.title}</h3>
                        <p>{movie.year}</p>
                        <img src={movie.poster} alt={movie.title} />
                    </li>
                    ))
                }
                </ul>
            )
        }     

    Estilos aplicados:
    Ej.
        .page {
            display:flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            max-width: 80rem;        
        }
        main {
            display: flex;
            justify-content: center;
            width: 100%;                    => importante si queremos que luego se muestre la grid
        }
        form {
            align-items: center;
            display: flex;
            justify-content: center;
        }
        .movies {
            list-style: none;
            margin: 0;
            padding: 0; 

            display: grid;
            width: 100%;
            grid-template-columns: repeat( auto-fit, minmax(20rem, 1fr) );  => se auto ocupa todo el espacio disponible con un mínimo de 20rem y si no puede se reparte con 1fr por película
            gap: 3.2rem;
        }   

        .movie {
            text-align: center;
        }        

        .movie h3, movie p {
            margin: 0;
        }

        .movi img {
            border-radius: 0.8rem;
            margin-top: 1.6rem;
        }

    IMPORTANTE: diferencias entre auto-fit y auto-fill
        	                        auto-fill	                                                            auto-fit
        🔁 Rellena con	    El mayor número de tracks posibles, incluso si están vacíos	            Solo tracks con contenido visible
        🪄 Espacios vacíos	  Reserva espacio para celdas vacías	                                 Colapsa celdas vacías
        ✅ Uso ideal	       Cuando quieres estructura constante	                        Cuando quieres que las celdas se expandan para ocupar espacio libre

123. IMPORTANTE: a los custom hook podemos pasarle parámetros
    Ej.
        export function useMovies ({ search }) {
            const [responseMovies, setResponseMovies] = useState([])

            const movies = responseMovies.Search

            const mappedMovies = movies?.map(movie => ({
                id: movie.imdbID,
                title: movie.Title,
                year: movie.Year,
                image: movie.Poster
            }))
            
            const getMovies = () => {
                if (search) {
                    setResponseMovies(withResults)
                }
                else {
                    setResponseMovies(withoutResults)
                }
            }

            return { movies: mappedMovies, getMovies }
        }

    Devuelve la función getMovies y el movies ya mapeados.

    La llamada desde el App sería:
    Ej.
        function App () {
            const { search, updateSearch, error } = useSearch()
            const { movies, getMovies } = useMovies({ search })

            ...
            return (
                ...
                <main>
                    <Movies movies={movies} />
                </main>        
            )
        }       

    Con esto tendríamos hecha la app sin hacer el fetch, tirando de nuestros json locales.

124. Hacemos el fetch:
    Ej.
        const getMovies = () => {
            if (search) {
                const response = await fetch(`https://www.omdbapi.com/?apikey=${API_KEY}&s=${search}`)
                const json = await response.json()

                const movies = json.Search

                // o con promesas

                fetch(`https://www.omdbapi.com/?apikey=${API_KEY}&s=${search}`)
                    .then( res => res.json )
                    .then( json => {
                        setResponseMovies(json)
                    })
            }
            else {
                setResponseMovies(withoutResults)
            }
        }

125. CLAVE ==>> miramos en nuestras herramientas de desarrollo si hemos hecho bien la llamada del fetch, ¿como? yendo a Network / Fetch/XHR y ahí veremos las llamadas 
    realizadas desde nuestra App. Le damos un click y veremos (pestaña Encabezados) por este orden si la URL que estamos llamando es la correcta (por ejemplo que se dirija a localhost y no a internet),
    el método utilizado para llamar (GET, POST, ...), si la respuesta que devuelve es la esperada: es un json con la pinta adecuada o no (pestaña Respuesta)

126. Extraemos la lógica del fetch a un servicio mejor que en un hook:
    Ej. 
        export const searchMovies = async ({ search }) => {
            if (search === '') return null

            try {
                const response = await fetch(`https://www.omdbapi.com/?apikey=${API_KEY}&s=${search}`)
                const json = await response.json()

                const movies = json.Search

                // hacemos el mapped movies en este servicio, no tiene porque estar en el custom hook
                return movies?.map(movie => ({          
                id: movie.imdbID,
                title: movie.Title,
                year: movie.Year,
                image: movie.Poster
                }))
            } catch (e) {
                throw new Error('Error searching movies')
            }
        }

    Ej.
        export function useMovies ({ search }) {
            const [movies, setMovies] = useState([])

            const getMovies = async () => {
                const newMovies = await searchMovies({ search })
                setMovies(newMovies)
            }

            return { movies, getMovies }
        }

    CLAVE ==>> para todo esto no hemos tocado nuestra App, solo el custom hook, que mientras cumpla el contrado de salida de { movies, getMovies } seguirá haciendo que nuestra App
    funcione correctamente.

127. Añadimos un control de carga y errores mediante estados en nuestro custom hook:
    Ej.
        export function useMovies ({ search }) {
            const [movies, setMovies] = useState([])
            const [loading, setLoading] = useState(false)
            // el error no se usa pero puedes implementarlo
            // si quieres:
            const [error, setError] = useState(null)

            const getMovies = async () => {
                try {
                    setLoading(true)
                    setError(null)
                    const newMovies = await searchMovies({ search })
                    setMovies(newMovies)
                } catch (e) {
                    setError(e.message)
                } finally {
                    // tanto en el try como en el catch
                    setLoading(false)
                }
            }

            return { movies, getMovies, loading }
        }

    En nuestra función principal ya podemos mostrar Cargando... o las películas cuando se hallan cargado:
    Ej.
        function App () {
            const { search, updateSearch, error } = useSearch()
            const { movies, getMovies, loading } = useMovies({ search })

            ...
            return (
                ...
                <main>
                    {loading ? <p>Cargando...</p> : <Movies movies={movies} />}
                </main>        
            )
        }       

128. CLAVE ==>> Uso de useRef para guardar el estado anterior. Podemos evitar que se vuelve a ejecutar la misma búsqueda que la última que hizo el usuario.
    Ej. 
        export function useMovies ({ search }) {
            const [movies, setMovies] = useState([])
            const [loading, setLoading] = useState(false)
            const [error, setError] = useState(null)
            const previousSearch = useRef(search)

            const getMovies = async () => {
                if (search == previousSearch.current) return
                try {
                    setLoading(true)
                    setError(null)
                    previousSearch.current = search
                    const newMovies = await searchMovies({ search })
                    setMovies(newMovies)
                } catch (e) {
                    setError(e.message)
                } finally {
                    // tanto en el try como en el catch
                    setLoading(false)
                }
            }

            return { movies, getMovies, loading }
        }

129. También se podría hacer con javascript definiendo el previousSearch con let fuera del cumtom hook, pero aunque funcionará no es buena práctica, ya que se compartiría
    esa misma variable en todos los usos del custom hook que utilizasemos. Es decir, el uso del custom hook no debería depender del import del archivo que lo incluye, ya que la
    importación es singletton y podríamos usar varias veces el useMovies en nuestro código.
    Ej.
        let previousSearch = ''

        export function useMovies ({ search }) {
            const [movies, setMovies] = useState([])
            const [loading, setLoading] = useState(false)
            const [error, setError] = useState(null)
            
            const getMovies = async () => {
                if (search == previousSearch.current) return
                try {
                    setLoading(true)
                    setError(null)
                    previousSearch.current = search
                    const newMovies = await searchMovies({ search })
                    setMovies(newMovies)
                } catch (e) {
                    setError(e.message)
                } finally {
                    // tanto en el try como en el catch
                    setLoading(false)
                }
            }

            return { movies, getMovies, loading }
        }

130. Creamos un estado para ordenar las peliculas por título:
    Ej.
        function App () {
            const { sort, setSort } = useState(false)
            const { search, updateSearch, error } = useSearch()
            const { movies, getMovies, loading } = useMovies({ search })

            const handleSort = () => {
                setSort(!sort)
            }

            ...
            return (
                <div className='page'>
                    <header>
                        <h1>Buscador de películas</h1>
                        <form className='form' onSubmit={handleSubmit}>
                            <input onChange={handleChange} value={search} name='query'
                                placeholder='Avengers, Star Wars, The Matrix...'
                            />
                            <input type='check' onChange={handleSort} value={sort}
                            <button type='submit'>Buscar</button>
                        </form>
                        {error && <p className='error'>{error}</p>}
                    </header>

                    <main>
                        {loading ? <p>Cargando...</p> : <Movies movies={movies} />}
                    </main>
                </div>
            )
        }       

    Pasamos al custom hook el sort como parámetro:
    Ej.
        export function useMovies ({ search, sort }) {
            const [movies, setMovies] = useState([])
            const [loading, setLoading] = useState(false)
            const [, setError] = useState(null)
            const previousSearch = useRef(search)

            const getMovies = async () => {
                if (search === previousSearch.current) return

                try {
                    setLoading(true)
                    setError(null)
                    previousSearch.current = search
                    const newMovies = await searchMovies({ search })
                    setMovies(newMovies)
                } catch (e) {
                    setError(e.message)
                } finally {
                    // tanto en el try como en el catch
                    setLoading(false)
                }
            }
            
            const sortedMovies = sort                                           => si tenemos chequeado el sort lo ordenamos sino no
                ? [...movies].sort((a, b) => a.title.localeCompare(b.title))    => el localCompare tiene en cuenta las tildes
                : movies            

            return { movies: sortedMovies, getMovies, loading }
        }

    Esto funciona, pero tiene un problema de rendimiento, porque no solo se aplica cuando el usuario da al buscar, también se renderiza de nuevo el componente el cambiar el texto del input
    de la búsqueda, provocando de nuevo la reordenación de las películas siendo innecesario.

    CLAVE ==>> en react el render es el cuerpo del componente, y en el caso de un custom hook es el cuerpo de la función. Todo lo que hay dentro se ejecutará de nuevo en caso de render.
    En un custom hook si cambiarmos el valor de un parámetro que recibe se entenderá como un renderizado del mismo porque tiene que volver a evaluar el cuerpo de la función para ese 
    nuevo valor.

131. CLAVE ==>> método de ordenación usado para respetar tildes, mayúsculas y demás:
    Ej.
        [...movies].sort((a, b) => a.title.localeCompare(b.title))   => compara y ordena por title

132. CLAVE ==>> useMemo : hook que permite memorizar un valor que se recalculará en función de unas dependencias, solo cuando cambien esas dependencias se volverá a ejecutar.
    Con este hook podemos evitar volver a ordenar esta lista si no ha cambiado:
    Ej.
        import { useRef, useState, useMemo } from 'react'
        import { searchMovies } from '../services/movies.js'

        export function useMovies ({ search, sort }) {
            const [movies, setMovies] = useState([])
            const [loading, setLoading] = useState(false)
            const [, setError] = useState(null)
            const previousSearch = useRef(search)

            const getMovies = async () => {
                if (search === previousSearch.current) return

                try {
                    setLoading(true)
                    setError(null)
                    previousSearch.current = search
                    const newMovies = await searchMovies({ search })
                    setMovies(newMovies)
                } catch (e) {
                    setError(e.message)
                } finally {
                    // tanto en el try como en el catch
                    setLoading(false)
                }
            }
            
            const sortedMovies = useMemo( () => {
                sort                                           => si tenemos chequeado el sort lo ordenamos sino no
                    ? [...movies].sort((a, b) => a.title.localeCompare(b.title))    => el localCompare tiene en cuenta las tildes
                    : movies            
            }, [ sort, movies ])      => indicamos que se recalcule o ejecute cuando cambie el check de ordenado o la lista de movies

            // como el search no es una dependencia de nuestro useMemo no se ejecuta aunque cambie el search.

            return { movies: sortedMovies, getMovies, loading }
        }

133. CLAVE ==>> no usar useMemo en todos los cálculos, a veces vale más la pensa realizar un pequeño cálculo de microsegundos que poner un useMemo para que no se haga.
    En nuestro ejemplo si supieramos que solo hay 10 películas no valdría la pena hacerlo.

134. CLAVE ==>> Podemos usar el useMemo también para memorizar funciones, y así evitar que se ejecuten cada vez que se renderiza el componente, pasando a ejecutarse solo 
    cuando hemos cambiado las dependencias de nuestro useMemo.
    Ej.
        const getMovies = useMemo( () => { 
            return async () => {
                if (search === previousSearch.current) return

                try {
                    setLoading(true)
                    setError(null)
                    previousSearch.current = search
                    const newMovies = await searchMovies({ search })
                    setMovies(newMovies)
                } catch (e) {
                    setError(e.message)
                } finally {
                    // tanto en el try como en el catch
                    setLoading(false)
                }
            }
        }, [search])

135. IMPORTANTE: Esto no es del todo eficiente, puesto que cada vez que cambiemos el input de la búsqueda nos volverá a generar la función, cuando en realidad lo que queremos es que la
    función se cree una sola vez y luego pasemos a llamarla cuando toque.
    Ej.
        const getMovies = useMemo( () => { 
            return async ({ search }) => {                      => como el search ya lo recibe como parámetro ya no hace falta tenerlo como dependencia
                if (search === previousSearch.current) return

                try {
                    setLoading(true)
                    setError(null)
                    previousSearch.current = search
                    const newMovies = await searchMovies({ search })
                    setMovies(newMovies)
                } catch (e) {
                    setError(e.message)
                } finally {
                    // tanto en el try como en el catch
                    setLoading(false)
                }
            }
        }, [])                                              =>  podemos indicarle que solo se genere la función al crear el componente, la primera vez.        

    CLAVE ==>> Se ejecutará la función solo cuando se llame, y se generará solo la primera vez que se cree nuestro componente o custom hook.

136. CLAVE ==>> para identificar problemas de rendimiento lo mejor es usar el Profiler de nuestras devtools de react en el explorador crhome

137. CLAVE ==>> Como el useMemo queda un poco raro usado para funciones, es una función que se crea para devolver otra función ... existe el hook useCallback que es lo 
    mismo que el useMemo pero pensado para funciones. Por debajo el useCallback utiliza el useMemo de la misma forma que vimos. De hecho es lo mismo pero te ahorras el return, ya que le pasas directamente la función:
    Ej.
        const getMovies = useCallback(
            async ({ search }) => {           => como el search ya lo recibe como parámetro ya no hace falta tenerlo como dependencia
                if (search === previousSearch.current) return

                try {
                    setLoading(true)
                    setError(null)
                    previousSearch.current = search
                    const newMovies = await searchMovies({ search })
                    setMovies(newMovies)
                } catch (e) {
                    setError(e.message)
                } finally {
                    // tanto en el try como en el catch
                    setLoading(false)
                }
        }, []) 

    La sintaxis se simplifica al pasarle directamente la función como primer parámetro y las dependencias como segundo.

138. ¿como implementar que se haga la búsqueda de forma automática al escribir? 
    Ej.
        const handleChange = (event) => {
            const newSearch = event.target.value
            updateSearch(newSearch)
            getMovies({search: newSearch})
        }  

    Simplemente con esto cada vez que escribimos modificando el input lanza una búsqueda y carga las películas.

139. CLAVE ==>> Pero nos piden que no haga búsquedas de forma continuada, es decir, actualmente si escribimos matrix en el input realizamos 6 búsquedas diferentes:
    una para la m, otra para la ma, otra para la mat, otra para la matr, otra para la matri, y finalmente una para matrix.
    Esto es ineficiente y también genera un problema de RaceCondition, es decir se lanzan varias búsquedas asíncronas pero no sabemos cuál es el orden de finalización de todas ellas, 
    pudiendo ser la última en acabar una de las búsquedas anteriores y mostrando en pantalla un resultado que no es el correspondiente a matrix.

140. CLAVE ==>> Debounce: es una técnica que nos sirve para resolver el problema anterior, no se va a lanzar la búsqueda de forma inmediata en cada letra tecleada por el usuario
    en el input, sino que se va a esperar un tiempo antes de hacer algo. Podríamos bajarnos librerías que ya lo implementan, incluso un custom hook que lo hace ya hecho.
    Pero vamos a desarrollarlo para aprender como lo haríamos. Recomiendo usar el debounce de la librería Just. Es muy fácil de entender: 
    Se inicia un timeout por ejemplo de 500ms, si se vuelve a llamar se reinicia el timeout a 500ms de nuevo, si no llama nadie cuando el timeout termina ejecuta la función.
    Este sería el funcionamiento del debounce, se puede cancelar.
    Ej.
        npm install just-debounce-it -E
    Si miramos hay varias formas de usar este debounce, se importa y luego se puede llamar sin ejecutarse hasta que venza el timeout establecido, también se puede lanzar ejecutándose la
    primera vez para darle info al usuario y luego ya cuando venza el siguiente timeout. También tenemos las opciones:
        cancel() -> que nos cancela el debounce y ya no se ejecutará la función.
        flush() -> que fuerza a que venza el timeout ejecutando la función de inmediato.

141. Lo implementamos en nuestra App:

    Lo importamos:
    Ej.
        import { useRef, useState, useMemo, useCallback } from 'react'
        import { searchMovies } from '../services/movies.js'
        import debounce from 'just-debounce-it'

    Lo que queremos es aplicar el debounce al getMovies que hay dentro del handleChange, no del que hay dentro del handleSubmit que siempre lo tiene que hacer, ni tampoco al propio handleChange, ya que eso evitaría que se viera por pantalla:

    Creamos el debounce:
    Ej.
        const debounceGetMovies = debounce( search => {
            getMovies(search)
        }, 500)             => 500ms

    Lo llamamos en lugar de llamar a getMovies en el handleChange:
    Ej.
        const handleChange = (event) => {
            const newSearch = event.target.value
            updateSearch(newSearch)
            debounceGetMovies(newSearch)
        }  
    IMPORTANTE: esto no funciona porque tenemos que la función del debounce se genera cada vez que se renderiza el componente, o sea cada vez que lo llamamos porque pasa al cambiar cualquier 
    letra del input. Para evitar esto usamos el useCallback:
    Ej.
        const debounceGetMovies = useCallback( debounce( search => {
                getMovies(search)
            }, 500)
        }, [])                  => podríamos poner getMovies como dependencia, pero ya hemos visto que nuestra getMovies es única y no cambia

    Ahora ya funciona todo.

---------------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------------  